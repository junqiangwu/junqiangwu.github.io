<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[交叉熵、KL、JS散度、Wasserstein距离]]></title>
    <url>%2F2019%2F03%2F27%2FKL%E3%80%81JS%E6%95%A3%E5%BA%A6%E3%80%81Wasserstein%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[交叉熵什么是信息量？ 假设XX是一个离散型随机变量，其取值集合为X，概率分布函数为p(x)=Pr(X=x),x∈p(x)=Pr(X=x),x∈X，我们定义事件X=x0X=x0的信息量为：I(x0)=−log(p(x0))I(x0)=−log(p(x0))，可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当p(x0)=1p(x0)=1时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。 123举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设： 事件A：小明考试及格，对应的概率P(xA)=0.1P(xA)=0.1，信息量为I(xA)=−log(0.1)=3.3219I(xA)=−log⁡(0.1)=3.3219 事件B：小王考试及格，对应的概率P(xB)=0.999P(xB)=0.999，信息量为I(xB)=−log(0.999)=0.0014I(xB)=−log⁡(0.999)=0.0014 可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的II值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的II值也非常的低。 什么是熵？熵的本质是(香农)信息量的期望值 数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，它反映随机变量平均取值的大小。 12它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。对于一个随机变量X而言，它的所有可能取值的信息量的期望（E[I(x)]）就称为熵。 当p取值为0、1时，整个系统十分稳定，所以信息熵为0，而当p=0.5时，系统最不稳定，信息熵最大；所以每一个系统都有一个真实的概率分布(真是分布)，而根据真实分布，我们可以选择一个最优策略消除系统的不确定性，而这个代价就是信息熵(信息熵衡量了系统的不确定性，而我们要消除这个不确定性，所要付出的【最小努力】（猜题次数、编码长度等）的大小就是信息熵) 1234567891. 例如有一个箱子，有橙、紫、蓝及青四种颜色的小球任意个，各颜色小球的占比不清楚，现在我从中拿出一个小球，你猜我手中的小球是什么颜色？ A: 假设均匀分布(1/4)，1/4概率是橙色球，小明需要猜两次，1/4是紫色球，小明需要猜两次，其余的小球类似，所以小明预期的猜球次数为： H = 1/4 * 2 + 1/4 * 2 + 1/4 * 2 + 1/4 * 2 = 22. 假设已知其中1/2是橙色球，1/4是紫色球，1/8是蓝色球及1/8是青色球。我从中拿出一个球，你猜我手中的球是什么颜色的？ A:1/2的概率是橙色球，小明需要猜一次，1/4的概率是紫色球，小明需要猜两次，1/8的概率是蓝色球，小明需要猜三次，1/8的概率是青色球，小明需要猜三次，所以小明猜题次数的期望为： H = 1/2 * 1 + 1/4 * 2 + 1/8 * 3 + 1/8 * 3 = 1.75 所以，每一个系统都会有一个真实的概率分布，也叫真实分布，题目1的真实分布为（1/4，1/4，1/4，1/4），题目2的真实分布为（1/2，1/4，1/8，1/8），而根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性，而这个代价大小就是信息熵，记住，信息熵衡量了系统的不确定性，而我们要消除这个不确定性，所要付出的【最小努力】（猜题次数、编码长度等）的大小就是信息熵。具体来讲，题目1只需要猜两次就能确定任何一个小球的颜色，题目2只需要猜测1.75次就能确定任何一个小球的颜色。 爸爸已经告诉小明这些小球的真实分布是（1/2，1/4, 1/8，1/8），但小明所选择的策略却认为所有的小球出现的概率相同，相当于忽略了爸爸告诉小明关于箱子中各小球的真实分布，而仍旧认为所有小球出现的概率是一样的，认为小球的分布为（1/4，1/4，1/4，1/4），这个分布就是非真实分布。此时，小明猜中任何一种颜色的小球都需要猜两次，即1/2 2 + 1/4 2 + 1/8 2 + 1/8 2 = 2。很明显，针对题目2，使用策略1是一个坏的选择，因为需要猜题的次数增加了，从1.75变成了2。因此，当我们知道根据系统的真实分布制定最优策略去消除系统的不确定性时，我们所付出的努力是最小的，但并不是每个人都和最强王者一样聪明，我们也许会使用其他的策略（非真实分布）去消除系统的不确定性，就好比如我将策略1用于题目2（原来这就是我在白银的原因），那么，当我们使用非最优策略消除系统的不确定性，所需要付出的努力的大小我们该如何去衡量呢？这就需要引入交叉熵，其用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小 什么是交叉熵 什么是相对熵？ KL散度 KL散度又称为相对熵，信息散度，信息增益。KL散度是是两个概率分布P和Q 差别的非对称性的度量(是两个随机分布间距离的度量)。 KL散度是用来 度量使用基于Q的编码来编码来自P的样本平均所需的额外的位元数。 典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。 相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略） 重点 12345有时会将KL散度称为KL距离，但它并不满足距离的性质：1. KL散度不是对称的:KL(A,B) ≠ KL(B,A)2. KL散度不满足三角不等式: KL(A,B) &gt; KL(A,C)+KL(C,B)3. 凸函数 KL散度越小 两则分布越相似 JS散度 JS散度度量了两个概率分布的相似度，基于KL散度的变体，解决了KL散度非对称的问题。一般地，JS散度是对称的，其取值是0到1之间。定义如下： 12345KL散度和JS散度度量的时候有一个问题：1. JS散度取值[0,1]，两者相同时为0，不同时为1；2. 如果两个分配P,Q离得很远，完全没有重叠的时候，那么KL散度值是没有意义的，而JS散度值是一个常数log2。3. 这在学习算法中是比较致命的，这就意味这这一点的梯度为0。梯度消失了。 Wasserstein距离 参考来源:知乎专栏]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成对抗网络_GAN_1]]></title>
    <url>%2F2019%2F03%2F25%2FGAN%E7%BD%91%E7%BB%9C-1%2F</url>
    <content type="text"><![CDATA[初识GAN 生成对抗网络(Generative Adversarial Nets,GAN)是由Good fellow在2014年提出的一种生成式模型，深度学习领域的图像生成，风格迁移，图像变换，图像描述，无监督学习，甚至强化学习领域都能看到GAN的身影； Wasserstein GAN 很详细知乎专栏、介绍Wasserstein GANhttps://zhuanlan.zhihu.com/p/25071913 GAN网络的生成原理GAN网络需要生成器和判别器两个模块，两者进行博弈对抗学习，让生成器G生成更真实的数据，让判别器D可以更好的判别假的(生成的)数据，其中生成器的输入为白噪声; GAN包括两个网络模型，一个生成模型G（generator）和一个判别模型D（discriminator），其中D就是识别检测类模型中经常使用的网络。GAN的大概流程是，G以随机噪声作为输入，生成出一张图像G(z)，暂且不管生成质量多好，然后D以G(z)和真实图像x作为输入，对G(z)和x做一个二分类，检测谁是真实图像谁是生成的假图像。D的输出是一个概率值，比如G(z)作为输入时D输出0.15，那么代表D认为G(z)有15%的概率是真图像。然后G和D会根据D输出的情况不断改进自己，G提高G(z)和x的相似度，尽可能的欺骗D，而D则会通过学习尽可能的不被G欺骗。二者相当于是做一个极大极小的博弈过程，称为零和博弈。 初代GAN_Loss设计 由于需要判别器D更好的判别真假，所以需要maxD,既D(x)更接近与1， 训练方法/流程 图2展示了GAN训练的伪代码，首先在迭代次数范围内，首先对z和x采样一个批次，获得他们的数据分布，然后通过随机梯度下降的方法先对D做k次更新，之后对G做一次更新，这样做的主要目的是保证D一直有足够的能力去分辨真假。实际在代码中我们可能会多更新几次G只更新一次D，不然D学习的太好，会导致训练前期发生梯度消失的问题 训练GAN的一些技巧 输入规范化到（-1，1）之间，最后一层的激活函数使用tanh（BEGAN除外） 使用wassertein GAN的损失函数， 如果有标签数据的话，尽量使用标签，也有人提出使用反转标签效果很好，另外使用标签平滑，单边标签平滑或者双边标签平滑 使用mini-batch norm， 如果不用batch norm 可以使用instance norm 或者weight norm 避免使用RELU和pooling层，减少稀疏梯度的可能性，可以使用leakrelu激活函数 优化器尽量选择ADAM，学习率不要设置太大，初始1e-4可以参考，另外可以随着训练进行不断缩小学习率， 给D的网络层增加高斯噪声，相当于是一种正则 存在的问题训练存在的问题 训练GAN需要达到纳什均衡,有时候可以用梯度下降法做到,有时候做不到.我们还没有找到很好的达到纳什均衡的方法,所以训练GAN相比VAE或者PixelRNN是不稳定的,但我认为在实践中它还是比训练玻尔兹曼机稳定的多 GAN不适合处理离散形式的数据，比如文本 GAN存在训练不稳定、梯度消失、模式崩溃的问题（目前已解决） 为什么GAN中的优化器不常用SGD SGD容易震荡，容易使GAN训练不稳定， GAN的目的是在高维非凸的参数空间中找到纳什均衡点，GAN的纳什均衡点是一个鞍点，但是SGD只会找到局部极小值，因为SGD解决的是一个寻找最小值的问题，GAN是一个博弈问题。 模式崩溃(model collapse)原因一般出现在GAN训练不稳定的时候，具体表现为生成出来的结果非常差，但是即使加长训练时间后也无法得到很好的改善。 具体原因可以解释如下：GAN采用的是对抗训练的方式，G的梯度更新来自D，所以G生成的好不好，得看D怎么说。具体就是G生成一个样本，交给D去评判，D会输出生成的假样本是真样本的概率（0-1），相当于告诉G生成的样本有多大的真实性，G就会根据这个反馈不断改善自己，提高D输出的概率值。但是如果某一次G生成的样本可能并不是很真实，但是D给出了正确的评价，或者是G生成的结果中一些特征得到了D的认可，这时候G就会认为我输出的正确的，那么接下来我就这样输出肯定D还会给出比较高的评价，实际上G生成的并不怎么样，但是他们两个就这样自我欺骗下去了，导致最终生成结果缺失一些信息，特征不全。 关于梯度消失的问题可以参考郑华滨的令人拍案叫绝的wassertein GAN，里面给出了详细的解释，不过多重复。]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体指针malloc注意]]></title>
    <url>%2F2019%2F03%2F22%2F%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88malloc%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[malloc动态申请内存12345678910111213141516171819202122232425262728293031323334353637# 定义链表结构体typedef struct ListNode&#123; int val; ListNode* next; ListNode()&#123;val=0;next==NULL;&#125;&#125;ListNode;int main()&#123; # 先定义ListNode对象，再将其地址赋值给ListNode*指针，即可找到正确的数据地址 ListNode buf; ListNode* tmp = &amp;buf;// ListNode* tmp = (ListNode*)malloc(sizeof(ListNode)); tmp-&gt;val=10; # 而malloc也会申请到结构体所需的空间大小，并且返回的tmp2已经保存了申请到的堆空间地址，可以对其直接进行操作// ListNode* tmp2 = (ListNode*)malloc(sizeof(ListNode)); # 如果不适用malloc申请内存，ListNode* tmp2仅仅为指针分配了内存，却不知道它所要指向对象的空间大小，既不能对其结构体数据进行操作； ListNode* tmp2; tmp2-&gt;val=11; tmp-&gt;next = tmp2; while(tmp!=NULL)&#123; printf(&quot;ListNode: %d \t&quot;,tmp-&gt;val); tmp= tmp-&gt;next; &#125; # free 只是告诉系统，之前占用的内存可以被重新分配，但是tmp的值(指向地址)并没有改变，此时还可以通过解引用操作其原指向的地址空间 free(tmp); free(tmp2); # 置为NULL 防止野指针 tmp = NULL; tmp2 = NULL; return 0;&#125; 网上介绍在使用结构体指针变量的时候，往往容易犯一个“低级”错误。即定义一个结构体指针变量后就直接对结构体指针变量所指向的结构体成员进行操作，从而产生一些莫名其妙的错误。我们必须要给结构体指针变量赋予一个有效的结构体变量地址，才能正常操作结构体指针变量。比如： 123456789101112struct UART&#123; int a; uchar b; &#125;void main()&#123; struct UART *p; p-&gt;a = 0xXXX; p-&gt;b = 0xXX; printf(&quot;%i,%c&quot;,p-&gt;b,p-&gt;a);&#125; 这个程序输出的值将是不可预知的，因为“在程序中只是定义了一个结构体指针变量，并没有给该结构体指针变量赋一个有效值，因此该结构体变量所指向的地址将不确定，从而不能得到预期结果” 修改12345678910void main()&#123; struct UART *p; struct UART dd； p = &amp;dd； //这句一定要有，否则将出现不可预知的问题 p-&gt;a = 0xXXX; p-&gt;b = 0xXX; printf(&quot;%i,%c&quot;,p-&gt;b,p-&gt;a);&#125;# 既我之前说的，单独申明一个指针，系统仅仅分配了指针所需的内存空间，并且没有有效值，所以也就不能通过这个指针去访问成员变量！ leetcode引发的案例 Merge Two Sorted Lists 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; # 1 申明指针，把有效地址赋给它 // ListNode dumpy(0); // ListNode* tmp=&amp;dumpy; # 2 直接申请 //ListNode* tmp = new ListNode(0); //ListNode* dump = tmp; # 3 直接申请 ListNode* tmp = (ListNode*)malloc(sizeof(ListNode)); ListNode* dump = tmp; while(l1!=NULL &amp;&amp; l2!= NULL)&#123; if(l1-&gt;val &lt;= l2-&gt;val)&#123; tmp-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; tmp-&gt;next = l2; l2 = l2-&gt;next; &#125; tmp = tmp-&gt;next; &#125; tmp-&gt;next = l1?l1:l2; // if(l1!=NULL)&#123; // tmp-&gt;next = l1; // &#125; // if(l2!=NULL)&#123; // tmp-&gt;next = l2; // &#125; return dump-&gt;next; &#125;&#125;; 注意 malloc申请的空间，最后一定要free，并且置为NULL，防止出现野指针的使用 单纯的使用ListNode* p定义指针，只会分配指针本身的4字节大小，不会附带申请其内部数据所需的空间大小 free函数是将分配的这块内存与指针（malloc返回的指针）之间的所有关系斩断，指针变量P中存储的地址（这块内存的起始地址）值也没有发生变化，同时存储器中存储的内容也并没有发生改变，改变的只是指针对这块内存地址的所有权问题。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[face++ 面经]]></title>
    <url>%2F2019%2F03%2F21%2Fface-%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[mxnet2caffe 以及适配Tensor RT 遇到的问题 mxnet和caffe的pooling操作，在取整细节上存在不同，mxnet是下取整，而caffe是上取整，通过逐层debug确定问题源,解决在Tensor RT引擎上重新实现pooling层，替换存在取整问题的pooling层 在读取mxnet的json文件构建caffe_net时，存在不支持的op，需要自己添加相应的层实现，分别添加了 brocadcast传播、channel_shuffle 操作 在调式Tensor RT引擎时，不可以debug指定层，通过添加test_layer，进行debug调试； 经典网络的实现特点 resnet的skip squeezenet的压缩 shufflenet的group_conv以及channel_shuffle SEnet的通道权重 mobilenet的深度可分离卷积，其结构参数量、计算量的推导计算 感受野的计算经过几个 conv 和 pooling 之后感受野的大小，(感受野的计算和 padding 无关)，只需关心 当前 k_size 和之前操作的 stride 的累乘 常用loss函数设计 cross_entropy 以及 展开式 softmax,将分类器最后的输出单元经过Softmax进行数值处理，转换到(0，1)的概率表示 cross_entropy: 交叉熵表示两个概率之间的相似性 均值平方和 MSE smollh_l1 回归损失，涉及到不同尺寸框的loss权重问题， 如100pixel的预测框和10pixel的预测框，分别偏移5pixel,那么如何修改loss可以更合理，可以使用 (h - h^)/100 表示大框的权重，既大框对相同偏移量应该更加迟钝， BN操作的细节实现 BN操作的公式 以及 可学习参数和相应的作用 BN归一化的维度，以及 归一化公式 min_max_normalization 需要求的数据的最大/小值，x^ = x- x_min/(x_max-x_min) zero_mean normalization 需要求的原数据的均值和方差 x^ = (x-u)/(α^2)经过处理的数据近似正态分布，所以一般添加斜率和偏置，丰富数据的特征 优化器的公式推导 及 优劣性 SGD的公式，其中moment惯量的作用，平滑梯度更新带来的抖动 adam的公式，当时没想起来adam的参数 对输入数据的常见操作就是很普通的操作，减均值~缩放(0.01)~翻转~裁剪等； 网络加速的措施 channel purning 通道修剪 紧凑型网络设计 稀疏矩阵 将feature map 矩阵分解，张量分解 权重量化 int8 float16 1234(1)人工设计轻量化神经网络模型；(2)基于神经网络架构搜索（Neural Architecture Search,NAS）的自动化设计神经网络；(3)CNN模型压缩；(4)基于AutoML的自动模型压缩 神经网络结构性搜索的实现 及 改进方向 结构搜索的三个主要措施： 搜索空间 优化策略 和 评价指标 重点介绍了FBNet网络的设计原理 及 mxnet的复现存在的问题，如多参数不同步更新、多卡加速训练存在的资源分配不均匀问题、学习率方法的优化(loss崩掉)； 介绍了FLOPs和实际延迟存在的区别，介绍了新的loss设计 介绍了搜索空间设计 NN方向的5个重点 model data optimiter loss metric 本科竞赛的相关经历 智能车 助力车 中断的实现和注意事项 传感器 算法题求最长递增子序列 当时给的解决方法，是使用栈进行遍历，寻找满足递增的最小下一个元素，最后求栈容量 实现sqrt函数 当时使用二分查找法解决，首先根据输入x，确定搜索区间，然后根据精度要求，不断调整区间，找到满足精度的点(存在的问题，确定区间大，没有很好的限制搜索区间，可以利用y=x 和 y= x^1/2 的曲线，确定更小的搜索空间) 二分查找 二分查找的递归实现 和 非递归实现 1234567891011121314151617181920212223242526272829303132333435float found(float x,float eps,float s,float e)&#123; float mid = (e+s)/2.0; int cnt=0; float buff = mid*mid; float tmp = buff - x;//// while(abs(tmp) &gt; eps)&#123;// printf("cnt %d %f %f %f \n ",cnt,s,e,mid);//// if(tmp&gt;0)&#123;// e = mid;// &#125;else&#123;// s = mid;// &#125;// mid=(s+e)/2;// tmp = mid*mid - x;// cnt++;// &#125;// return mid; if(abs(tmp) &lt;= eps)&#123; printf("return %f \n",mid); return mid; &#125; if(tmp &gt;0)&#123; return found(x,eps,s,mid); &#125;else&#123; return found(x,eps,mid,e); &#125;&#125; 牛顿迭代 12345678910111213float NewTown(float x,float eps)&#123; float x0,x1= x/2.0; int cnt=0; // 迭代次数 while(abs(x1-x0) &gt;= eps)&#123; x0 = x1; // printf("cnt: %d %f \n ",cnt,x0); x1 = x0 - (x0*x0-x)/(2.0*x0); // x1 = 1.0/2*(x0+x/x0); cnt++; &#125; return x1;&#125; 二叉树的层序遍历1.使用队列进行层次遍历即可，熟练 1234567891011121314void csearch(PTREE Root)&#123; std::queue&lt;PTREE&gt; cur; // STL库的队列实现 if(Root==NULL) return; cur.push(Root); while(!cur.empty())&#123; if(cur.front()-&gt;left!=NULL) cur.push(cur.front()-&gt;left); if(cur.front()-&gt;right!=NULL) cur.push(cur.front()-&gt;right); printf("123 \t %d",cur.front()-&gt;data); cur.pop(); &#125;&#125; 返回数组中最早满足 target 的元素索引 肯定存在结果，不能进行排序，因为要返回最早满足关系的两个索引，不可以双层for 遍历，时间上太慢，考虑到使用 map 的特性进行查找，如果map 中不存在，则插入 map，这样遍历一遍数组即可找到答案O(n) 1234567891011121314void found_target()&#123; int nums[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int target = 8; map&lt;int,int&gt; m; for(int i=0;i&lt;10;i++)&#123; if(m.find(target - nums[i]) != m.end())&#123; printf("%d %d ",i,m[target - nums[i]]); return ; &#125; m[nums[i]] = i; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法 牛顿法 求sqrt]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BA%8C%E5%88%86%E6%B3%95-%E7%89%9B%E9%A1%BF%E6%B3%95-%E6%B1%82sqrt%2F</url>
    <content type="text"><![CDATA[使用二分法 首先确定二分法查找的首尾区间，然后根据abs(mid^2-target)&lt;eps的误差进行区间的移动，寻找满足精度的位置 存在的问题: 第一步寻找合适的搜索区间，我们从函数曲线上可以看出，y=x和y=√x在x=1时交集； 当待开根号数在(0,1)之间时，搜索区间也在(0,1)，当待开根号数tar&gt;1时，区间在[1,x] 实现 12345678910111213141516171819202122232425float found(float x,float eps,float s,float e)&#123; float mid = s+(e-s)/2.0; float tmp = mid*mid - x; if(abs(tmp) &lt;= err)&#123; return mid; &#125; if(tmp &gt;0)&#123; return found(x,eps,s,mid); &#125;else&#123; return found(x,eps,mid,e); &#125;&#125;float sqrt(float x,float eps)&#123; if (x&lt;0) return -1; if (x==0) return 0; if(0&lt;x &amp;&amp; x&lt;1)&#123; return found(x,eps,0.,1.); &#125;else&#123; return found(x,eps,1,x); &#125; &#125; 二分法的非递归实现1234567891011121314151617float found(float x,float eps,float s,float e)&#123; float mid = (e+s)/2.0; float tmp = mid*mid - x; while(abs(tmp) &gt; eps)&#123; printf(&quot;cnt %d %f %f %f \n &quot;,cnt,s,e,mid); if(tmp&gt;0)&#123; e = mid; &#125;else&#123; s = mid; &#125; mid=(s+e)/2; tmp = mid*mid - x; &#125; return mid;&#125; 使用牛顿迭代法 仔细思考一下就能发现，我们需要解决的问题可以简单化理解。 从函数意义上理解：我们是要求函数f(x) = x²，使f(x) = num的近似解，即x² - num = 0的近似解。 从几何意义上理解：我们是要求抛物线g(x) = x² - num与x轴交点（g(x) = 0）最接近的点。 实现 12345678910111213141516float NewTown(float x,float eps)&#123; float x0,x1= x/2.0; int cnt=0; while(abs(x1-x0) &gt;= eps)&#123; x0 = x1; printf(&quot;cnt: %d %f \n &quot;,cnt,x0); x1 = x0 - (x0*x0-x)/(2.0*x0);// x1 = 1.0/2*(x0+x/x0); cnt++; &#125; return x1;&#125; 使用牛顿迭代法求多项式的一个根12定区间，找中点，中值计算两边看。 同号去，异号算，零点落在异号间。 实现123456789101112131415161718float NewTown2()&#123; float x,x1=1; int a=1,b=2,c=3,d=4; float f,f1; while(abs(x1-x) &gt;0.001)&#123; x=x1; f = ((a*x+b)*x+c)*x + d; f1 = (3*a*x+2*b)*x+c; x1 = x - f/f1; &#125; printf(&quot;newtown2 %.10f&quot;,x1); return x1;&#125; 牛顿迭代法 五次及以上多项式方程没有根式解（就是没有像二次方程那样的万能公式) 牛顿迭代法（Newton’s method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。 切线是曲线的线性逼近 求高阶方程式的近似解， 比如我们要开平方根，则可以转换为求x^2 - a = 0的实数根，根据x_n+1 = x_n - f(x_n)/f’(x_n) ,不断迭代新的切线，直到找到近似解，f(x)和x轴的交点 不收敛的情况：驻点起始点不幸选择了驻点，从几何上看切线根本没有根。 越来越远离的不收敛 循环震荡的不收敛 不能完整求出所有的根 总结应用牛顿-拉弗森方法，要注意以下问题：函数在整个定义域内最好是二阶可导的起始点对求根计算影响重大，可以增加一些别的判断手段进行试错 牛顿法求极值 梯度下降求极值其实牛顿迭代法也可以很方便的求极值，只要x=x−f’(x)/f”(x)这样求的就是，f’(x)与x轴的交点，既导数的零点，也即是f(x)的极值点]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[构建二叉树Tree高度延伸的一类题目 104. Maximum Depth of Binary Tree最基础的递归，先递归到底，当Leaf Node的左右两个Children Node都分别触及Base Case，也就是None的时候，向上返回。然后之后对应当前node，左右两边的递归都操作结束以后，返回的过程中对左右高度进行对比，取两个中间最大值，然后这里记住要加1，也就是当前的层数。 12345678class Solution(object): def maxDepth_gd(self, root): if not root: return 0 left = self.maxDepth(root.left) right = self.maxDepth(root.right) return max(left, right) + 1 110. Balanced Binary Tree有了104的基础，我们在延伸下看看110这道题，其实就是基于高度计算，然后判断一下。 但由于嵌套的Recursion调用，整体的时间复杂度是：O(nlogn) , 在每一层调用get_height的平均时间复杂度是O(N)，然后基于二叉树的性质，调用了的高度是logn，所以n * logn 的时间复杂。 时间复杂度为什么是nlogn搞不清楚的看 时间复杂度图解123456789101112131415class Solution(object): def isBalanced(self, root): if not root: return True left = self.get_height(root.left) right = self.get_height(root.right) if abs(left - right) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) def get_height(self, root): if not root: return 0 left = self.get_height(root.left) right = self.get_height(root.right) return max(left, right) + 1 上面这种Brute Froce的方法，整棵树有很多冗余无意义的遍历，其实我们在处理完get_height这个高度的时候，我们完全可以在检查每个节点高度并且返回的同时，记录左右差是否已经超过1，只要有一个节点超过1，那么直接返回False即可，因此我们只需要在外围设立一个全球变量记录True和False，在调用get_height的时候，内置代码里加入对左右高度的判定即可，代码如下 时间复杂度: O(N) Recursive Rules: 索取：Node的左孩子是不是全部是Balanced，Node的右孩子是不是全部是Balanced的，返回：如果都是Balanced的，返回True，不然返回False 1234567891011121314class Solution(object): def isBalanced(self, root): self.flag = False self.getHeight(root) return not self.flag def getHeight(self, root): if not root: return 0 left = self.getHeight(root.left) right = self.getHeight(root.right) if abs(left - right) &gt; 1: self.flag = True return max(left, right) + 1 最后Leetcode上有一种-1的方法，其实就是上面这种方法的一种延伸。如果左右两边出现了高度差高于1的情况，直接返回-1，这个-1怎么来的？因为高度不可能为负数，-1其实就是一种True/False的表达。 那么在实现上，我们只要对get_height每次返回前做一个判定即可，具体实现看下方： 时间复杂度: O(N) 12345678910111213class Solution(object): def isBalanced(self, root): height = self.get_height(root) return height != -1 def get_height(self, root): if not root: return 0 left = self.get_height(root.left) right = self.get_height(root.right) if left == -1 or right == -1 : return -1 if abs(left - right) &gt; 1: return -1 return max(left, right) + 1 111. Minimum Depth of Binary Tree 返回叶子 (无左右孩子的节点) 节点的最小深度 123456789101112131415161718192021222324252627282930313233343536373839404142434445int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; int dep =1; queue&lt;TreeNode*&gt; q_cur,q_next; q_cur.push(root); while(!q_cur.empty())&#123; TreeNode* a = q_cur.front(); q_cur.pop(); if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL) return dep; if(a-&gt;left!=NULL) q_next.push(a-&gt;left); if(a-&gt;right!=NULL) q_next.push(a-&gt;right); if(q_cur.empty())&#123; swap(q_cur,q_next); dep+=1; &#125; &#125; return dep; &#125;# 或者使用一个队列 每一次层次遍历 都提前计算出当前层的size 既当前层的元素数量// while(!q.empty())&#123;// int size = q.size();// while(size&gt;0)&#123;// TreeNode* a = q.front();// q.pop(); // if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL) // return dep;// if(a-&gt;left!=NULL)// q.push(a-&gt;left);// if(a-&gt;right!=NULL)// q.push(a-&gt;right);// size--;// &#125; // dep+=1;// &#125; 112. Path Sum 路径数值和普通的dfs 递归1234567bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; sum-root-&gt;val==0) return true; return hasPathSum(root-&gt;left,(sum-root-&gt;val)) || hasPathSum(root-&gt;right,(sum-root-&gt;val)); &#125; 利用栈实现的非递归dfs123456789101112131415161718192021222324252627282930bool hasPathSum(TreeNode* root, int sum) &#123; if(root==NULL) return false; stack&lt;TreeNode*&gt; s; stack&lt;int&gt; s_n; s.push(root); s_n.push(root-&gt;val); while (!s.empty())&#123; TreeNode* a = s.top(); int b = s_n.top(); s.pop(); s_n.pop(); if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL &amp;&amp; b==sum) return true; if(a-&gt;left!=NULL)&#123; s.push(a-&gt;left); s_n.push(b+a-&gt;left-&gt;val); &#125; if(a-&gt;right!=NULL)&#123; s.push(a-&gt;right); s_n.push(b+a-&gt;right-&gt;val); &#125; &#125; return false; &#125; 输出Tree的路径value 257. Binary Tree Paths 递归dfs 实现123456789101112131415161718192021void dfs(TreeNode* root,string str,vector&lt;string&gt;&amp; res)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123; res.push_back(str); &#125; if(root-&gt;left!=NULL)&#123; dfs(root-&gt;left,str+"-&gt;"+to_string(root-&gt;left-&gt;val),res); &#125; if(root-&gt;right!=NULL)&#123; dfs(root-&gt;right,str+"-&gt;"+to_string(root-&gt;right-&gt;val),res); &#125; &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(root == NULL) return res; string str = to_string(root-&gt;val); dfs(root,str,res); return res; &#125; 使用Stack 进行的非递归遍历12345678910111213141516171819202122232425262728293031vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(root == NULL) return res; stack&lt;TreeNode*&gt; s; stack&lt;string&gt; str_s; s.push(root); str_s.push(to_string(root-&gt;val)); string str; while(!s.empty())&#123; TreeNode* a = s.top(); str = str_s.top(); s.pop(); str_s.pop(); if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL)&#123; res.push_back(str); str.erase(str.end()-1); &#125; if(a-&gt;left!=NULL)&#123; s.push(a-&gt;left); str_s.push(str+"-&gt;"+to_string(a-&gt;left-&gt;val)); &#125; if(a-&gt;right!=NULL)&#123; s.push(a-&gt;right); str_s.push(str+"-&gt;"+to_string(a-&gt;right-&gt;val)); &#125; &#125; reverse(res.begin(),res.end()); return res; 翻转二叉树 226. Invert Binary Tree dfs 遍历每一个节点 进行交换1234567891011121314TreeNode* invertTree(TreeNode* root) &#123; dfs_invert(root); return root;&#125;void dfs_invert(TreeNode* root)&#123; if(root == NULL) return; invertTree(root -&gt; left); invertTree(root -&gt; right); // swap after the left subtree and right subtree has been done swap(root -&gt; left, root -&gt; right);&#125; queue_BFS 123456789101112131415161718192021TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode* node = q.front(); q.pop(); #只需要交换 非叶子节点的左右孩子即可 if (node-&gt;left != NULL || node-&gt;right != NULL) &#123; TreeNode* temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; &#125; if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); &#125; return root; &#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL]]></title>
    <url>%2F2019%2F03%2F12%2FSTL%2F</url>
    <content type="text"><![CDATA[C++序列式容器 array&lt;T,N&gt;(数组容器)是一个长度固定的序列，有N个T类型的对象，不能增加或删除元素 vector(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素 deque(双向队列容器)是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素 list(链表容器)是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。 forward list(正向链表容器)它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问 Vector vector 容器可以方便、灵活地代替数组array。在大多数时候，都可以用vector 代替数组存放元素,vector 在扩展容量,以及在序列内部删除或添加元素时会产生一些开销；但大多数情况下,代码不会明显变慢. ListStringMap 在关联容器中，对象的位置取决于和它关联的键的值。键可以是基本类型，也可以是类类型。字符串经常被用来作为键，如果想要保存姓名和地址的记录，就可以这么使用 HashSet]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法随笔]]></title>
    <url>%2F2019%2F03%2F11%2F%E7%AE%97%E6%B3%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[##算法随笔 原地删除重复的数字 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 实现1234567891011121314int remove_duplicates(int a[],int size)&#123; int index = 0; for (int i=0;i&lt;size;i++)&#123; // 一直寻找到不重复的元素，进行交换，index+1 if(a[index] != a[i])&#123; index++; a[index] = a[i]; &#125; &#125; index++; return index;&#125; 数组中出现次数超过一半的元素 数组(无序)中有一个数字出现的次数超过了数组长度的一半，找出这个数字。 解法1 如果数据量小，可以对数组进行排序，那么数组中间n/2的数就是出现次数超过一半的数,复杂度O(nlogn) 解法2 每次删除数组中两个不同的元素，删除后，要查找的那个元素的个数仍然超过删除后的元素总数的一半 需要两个辅助参数，一个是出现的数值，一个是该数值出现的次数 123456789101112131415161718192021template &lt;typename T&gt;void FindOneNumber(T a[],int size)&#123; if( size &lt;= 0) return -1; int nTimes = 1; int pre = a[0]; for(int i=1;i&lt;size;i++)&#123; if (pre == a[i])&#123; nTimes++; &#125;else&#123; if(nTimes==0)&#123; pre = a[i]; nTimes=1; &#125;else&#123; nTimes--; &#125; &#125; &#125; return pre;&#125; 将数值向右移动K个位置(非负数)解法1 每次遍历数组，可以向后移动一位，移动k个位置，则需要k次遍历，O(k*n) 123456789101112void move_k(int a[],int size,int k)&#123; // 求需要移动的最小步数， int loca = size%k; for(int i=0;i&lt;loca;i++)&#123; int tmp = a[size-1]; for(int j=size-1;j&gt;=1;j--)&#123; a[j] = a[j-1]; &#125; a[0] = tmp; &#125;&#125;# 时间复杂度 O(k*n) size/k 解法2 借助O(n)的空间，将数组复制到新数组中，然后遍历重新赋值即可，时间O(n)string 形参，可以使用引用const string&amp; str，减少内存的拷贝 12345678910void move_k(int a[],int size,int k)&#123; int loca = size%k; int tmp[size]; # C风格的数组复制方法(memset etc.) memcpy(tmp,a,size*sizeof(int)); for(int i=0;i&lt;size;i++)&#123; a[(i+loca)%size] = tmp[i]; &#125;&#125; 判断重复数字 长度为n的数组，赋值为1~n，判断是否存在重复元素 这个数组的特性是，1~n每个值都使用一次才会不重复，所以我们可以将数组对应位置设置为对应的值，去判断是否为冲突 123456789101112131415161718//遍历数组，假设第i个位置的数字为j，则通过交换将j换到下标为j的位置上，直到所有数字都出现在自己对应的下表处，或发生了冲突。//时间复杂度：O(n)，空间复杂度：O(1)bool find_dup(int a[],int size)&#123; if(size&lt;=1) return false; for(int i=0;i&lt;size;i++)&#123; int index = a[i]; if(index-1== i) continue; // 交换前index位置处已经存在index值，这个数字重复 if(a[index-1]==index)&#123; return false; &#125; a[i] = a[index-1]; a[index-1] = index; &#125;&#125; 变形2 普通的数组，则可以通过排序，然后判断前后元素是否相同来确定是否有重复元素 或者利用STL库的set容器，它保存有序的无重复的数组，支持插入，删除，查找等操作，所有的操作的都是严格在logn时间之内完成，效率非常高 1return nums.size() &gt; set&lt;int&gt;(nums.begin(),nums.end()).size(); 找出只出现一次的元素 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。(线性复杂度) 解法1 因为其它元素都出现两次，只有一个出现一次，就可以将数组先排序，然后以步长2遍历一次数组，找到 a[i] != a[i+1] 的即可 解法2 可以使用异或运算进行判定，由于都是出现偶数次，而0⊕0=0,1⊕0=1,0⊕1=1,1⊕1=0,且异或满足交换律，所以可以对整个数组进行异或运算，最后得到的结果即为单次出现的数字 12int arr[5] = &#123;4,2,1,2,4&#125;4⊕2⊕1⊕2⊕4 = 4⊕4⊕2⊕2⊕1 = (0)⊕(0)⊕1 = 1 实现 1234567int find_dup2(int a[],int size)&#123; int temp = 0; for(int i=0;i&lt;size;i++)&#123; temp = temp^a[i]; &#125; return temp;&#125; 求数组的交集 给定两个数组，编写一个函数来计算它们的交集。 12345输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解法112345678910111213# 最暴力的方法，时间O(n^2) void find_jiao(int a[],int b[],int size_a,int size_b)&#123; vector&lt;int&gt; c; for(int i=0;i&lt;size_a;i++)&#123; int tmp = a[i]; for(int j=0;j&lt;size_b;j++)&#123; if(tmp == b[j])&#123; c.push_back(tmp); b[j] = -1; break; //找到一样的则跳出，比对第一层遍历数组中的下一个数值 &#125;&#125;&#125;&#125; 排序数组，找交集 如果两个数组是有序的，则可以分别设置一个索引，如果a[index1]&lt;b[index2],则a索引+1，反之亦然，如果两者相等，则存储当前值，并且两个索引都+1 12345678910111213141516171819202122vector&lt;int&gt; find_jiao(int a[],int b[],int size_a,int size_b)&#123; int index1 = 0,index2 = 0; vector&lt;int&gt; c; shell_sort(a,size_a); shell_sort(b,size_b); while(index1&lt;size_a &amp;&amp; index2&lt;size_b)&#123; if(a[index1] &lt; b[index2])&#123; index1++; &#125; else if(a[index1] &gt; b[index2])&#123; index2++; &#125; else&#123; c.push_back(a[index1]); index1++; index2++; &#125; &#125; return c;&#125; Plus One 加1 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字,你可以假设除了整数 0 之外，这个整数不会以零开头。 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 实现123456789101112void plus_one(int a[],int size)&#123; for(int i=size-1;i&gt;=0;i--)&#123; if(a[i]&lt;9 )&#123; a[i]+=1; break; &#125;else&#123; a[i]=0; i++; &#125; &#125;&#125; 移动所有的0到末尾 使用一个索引标志，遍历一次数组，遍历的同时将非0的元素交换到标志索引处，最后将剩余位置填充0即可！ 123456789101112void move_zero(int a[],int size)&#123; int i=0; for(int x=0;x&lt;size;x++)&#123; if(a[x]!=0) &#123; a[i] = a[x]; i++; &#125; &#125; for(;i&lt;size;i++)&#123; a[i]=0; &#125;&#125; 反转字符串 输入: “A man, a plan, a canal: Panama”输出: “amanaP :lanac a ,nalp a ,nam A” 123456789101112void reverseString(string&amp; str)&#123; int i=0,j=str.size()-1; while(i&lt;j)&#123;// swap(str[i++],str[j--]); char s = str[i]; str[i] = str[j]; str[j] = s; i++;j--; &#125; printf("\n str: %s \n",str.c_str());&#125; 字母异位词 利用了字母易位词即为各个字母的数目相同，而顺序不一致。我们从另外一个角度思考，字母一共有多少个？很明显，只有26个（只考虑小写字母）。那么，我们可以为字符串s1和s2分别设置26个计数器，然后判断这对应位置的计数是否相等，如果对应计数完全相等，则为字母易位词 12输入: s = "anagram", t = "nagaram"输出: true 实现 123456789101112131415161718bool isAnagram(string s, string t) &#123; if( s.size() != t.size()) return false; int cnt1[26],cnt2[26]; memset(cnt1,0,26* sizeof(int)); memset(cnt2,0,26* sizeof(int)); for(int i=0;i&lt;s.size();i++)&#123; cnt1[s[i]-'a']++; cnt2[s[i]-'a']++; &#125; for(int i=0;i&lt;26;i++)&#123; if(cnt1[i] != cnt2[i]) return false; &#125; return true;&#125; 回文字符串/**11. 回文字符串 **/ 123456789101112bool isPalindrome(const string&amp; s) &#123; int i=0, j=s.size()-1; while(i&lt;j)&#123; while (!isalnum(s[i]) &amp;&amp; i&lt;j) ++i; while (!isalnum(s[j]) &amp;&amp; i&lt;j) --j; if (toupper(s[i])!= toupper(s[j])) return false; i++; j--; &#125; return true;&#125; 查找字符串数组最长前缀1234例：输入: [“flower”,”flow”,”flight”] 输出: “fl” 示例 2:输入: [“dog”,”racecar”,”car”] 输出: “” 解释: 输入不存在公共前缀。 说明:# 所有输入只包含小写字母 a-z 1234567891011121314151617string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res; if(strs.empty())&#123; return &quot;&quot;; &#125; for(int i=0;i&lt;strs[0].size();i++)&#123; char c=strs[0][i]; for(int j=1;j&lt;strs.size();j++)&#123; if(i&gt;strs[j].size()-1||c!=strs[j][i])&#123; return res; &#125; &#125; res.push_back(c); &#125; return res; &#125; 合并两个有序链表1234将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 实现1234567891011121314151617181920212223242526ListNode* Merge_two(ListNode *l,ListNode* r)&#123; if(l-&gt;next==NULL &amp;&amp; r-&gt;next==NULL) return NULL; ListNode dumpy(0); ListNode* tmp=&amp;dumpy; while(l-&gt;next!=NULL &amp;&amp; r-&gt;next!=NULL)&#123; if(l-&gt;val &gt; r-&gt;val)&#123; tmp-&gt;next = r; r = r-&gt;next; &#125;else&#123; tmp-&gt;next = l; l = l-&gt;next; &#125; tmp = tmp-&gt;next; &#125; if(l!=NULL)&#123; tmp-&gt;next=l; &#125; if(r!=NULL)&#123; tmp-&gt;next=r; &#125; return tmp.next;&#125; 合并有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 1234输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 实现 12 数组最大子序和123输入: &#123;1, -2, 3, 10, -4, 7, 2, -5&#125;,输出: 18解释: 最大的子数组为｛3, 10, -4, 7, 2&#125;，和为18 解法1123456789101112# O(n^2) 遍历数组的每一个子序列，记录最大值void maxSubArray(int a[],int size) &#123; int sumMax = 0; for(int l=0;l&lt;size;l++)&#123; int tmp = a[l]; for(int r=0;r&lt;size;r++) &#123; tmp+= a[r]; sumMax = sumMax&gt;tmp?sumMax:tmp; &#125; &#125;&#125; 解法2 我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为 0。第一步加上第一个数字 1， 此时和为 1。接下来第二步加上数字 -2，和就变成了 -1。第三步刷上数字3。我们注意到由于此前累计的和是 －1 ，小于 0，那如果用-1 加上 3 ，得到的和是 2 ， 比 3 本身还小。也就是说从第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和。因此我们不用考虑从第一个数字开始的子数组，之前累计的和也被抛弃。 我们从第三个数字重新开始累加，此时得到的和是 3。接下来第四步加 10，得到和为 13 。第五步加上 -4， 和为 9。我们发现由于 -4 是一个负数，因此累加 -4 之后得到的和比原来的和还要小。因此我们要把之前得到的和 13 保存下来，它有可能是最大的子数组的和。第六步加上数字 7，9 加 7 的结果是 16，此时和比之前最大的和 13 还要大， 把最大的子数组的和由 13 更新为 16。第七步加上 2，累加得到的和为 18，同时我们也要更新最大子数组的和。第八步加上最后一个数字 -5，由于得到的和为 13 ，小于此前最大的和 18，因此最终最大的子数组的和为 18 ，对应的子数组是｛3, 10, -4, 7, 2｝。 根据数组的规律，去进行逐个累加，废弃对最大和没有作用的子序列 实现 1234567891011void maxSubArray(int a[],int size)&#123; int cur=0; int max=0; for(int i=0; i&lt;size; i+=1)&#123; cur += a[i]; // 如果小于0 则丢弃之前子序列的和 从下个索引处开始重新累加 cur = cur&gt;0?cur:0; // 更新最大的子序列和 max = max&gt;cur?max:cur; &#125;&#125; 何时买卖股票_121完成一次交易 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票 12345输入: [7,1,5,3,6,4]输出: 5解释: 在第2天(股票价格 = 1)的时候买入，在第5天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5,注意利润不能是7-1 =6;输入：[7,6,4,3,1] 这种情况输出0 分析: 其实这个和上面的最大序列和一样，我们可以将价格序列相减，可以得到[0,-6,4,-2,3,-2],然后我们从这个序列中找最大子序列和即可，[4,-2,3]=5即为最大收益 12345678910111213141516171819202122232425# Time O(n) Space O(n)void MaxProfit(int a[],int size)&#123; int buff[size-1]; # 存储收益差 for(int i=0;i&lt;size-1;i++)&#123; buff[i] = a[i+1] - a[i]; &#125; int cur=0; int max=0; for(int i=0;i&lt;size-1;i++)&#123; cur += buff[i]; cur = cur&gt;0?cur:0; max = max&gt;cur?max:cur; &#125;&#125;# 或者不另外开辟空间存储收益差也可以，改动如下： Space o(1) for(int i=1;i&lt;size;i++)&#123; if (cur &lt;= 0)&#123; cur = 0; &#125; cur += a[i]-a[i-1];; max = max&gt;cur?max:cur; &#125; 可以完成多次交易唯一的区别在于 上面是求最大利润 这个是求有效利润和 sum+=temp 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sum=0; if(prices.size()==0) return 0; for(int i=0;i&lt;prices.size()-1;i++)&#123; int temp = prices[i+1] - prices[i]; if(temp&gt;0) sum+=temp; &#125; return sum; &#125;&#125;; Pascal’s Triangle__118 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result; for(int i=0;i&lt;numRows;i++)&#123; if(i==0) &#123; vector&lt;int&gt; x(1,1); result.push_back(x); &#125; else if(i==1) &#123; vector&lt;int&gt; x(2,1); result.push_back(x); &#125; else&#123; vector&lt;int&gt; buff; buff.push_back(1); for(int j=0;j&lt;i-1;j++)&#123; buff.push_back(result[i-1][j] + result[i-1][j+1]); &#125; buff.push_back(1); result.push_back(buff); &#125; &#125; return result; &#125;&#125;; 多层vector容器的赋值问题 1234567891011121314vector&lt;vector&lt;int&gt;&gt; v;vector&lt;int&gt; buff;# 由于最外层的vector里放着更小的vector，所以需要先赋值里层的vector，再将里层vector作为元素push 到外层vector中//输入 for (int i = 0; i&lt;n; i++) &#123; buff.clear(); //每次记得clear:) for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; temp; buff.push_back(temp); &#125; v.push_back(buff); &#125; Max Consecutive Ones__485. 给定二进制数组，找到此数组中连续1的最大数量1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3 实现 123456789101112131415161718class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); int max=0,cur=0; for(int i=0;i&lt;size;i++)&#123; # 如果是1 则计数加1 非1 则清0 重新计数 if(nums[i] == 1)&#123; cur++; &#125;else&#123; cur=0; &#125; # 取最大的连续数 max = max&gt;cur?max:cur; &#125; return max; &#125;&#125;; 第三个大数字 Third Maximum Number__414 给定非空的整数数组，返回此数组中的第三个最大数字。 如果不存在，则返回最大数量。 时间复杂度必须是O（n） 12345Input: [3, 2, 1]Output: 1Input: [1, 2]Output: 2 max 实现123456789101112131415161718192021int thirdMax(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); double max0=-1*DBL_MAX,max1=-1*DBL_MAX,max2=-1*DBL_MAX; for(int i=0;i&lt;size;i++)&#123; # 遍历一次 逐步更新前三个最大值 if(nums[i]&gt;max0)&#123; max2 = max1; max1 = max0; max0 = nums[i]; &#125;else if(nums[i]&gt;max1 &amp;&amp; nums[i]&lt;max0)&#123; max2 = max1; max1 = nums[i]; &#125; else if(nums[i]&gt;max2 &amp;&amp; nums[i]&lt;max1)&#123; max2 = nums[i]; &#125; &#125; # 如果第三大不存在，则返回最大值 return max2 != -1*DBL_MAX? max2:max0; &#125; 找连续分组的位置 Positions of Large Groups__830 给定字符串，找出包含3及以上的所有分组的位置索引 12345678910Input: "abbxxxxzzy"Output: [[3,6]]Explanation: "xxxx" is the single large group with starting 3 and ending positions 6.Input: "abc"Output: []Explanation: We have "a","b" and "c" but no large group.Input: "abcdddeeeeaabbbcd"Output: [[3,5],[6,9],[12,14]] 实现1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string S) &#123; vector&lt;int&gt; buf; vector&lt;vector&lt;int&gt;&gt; result; int cnt=1; int size = S.size(); for(int i=0;i&lt;size;i++)&#123; if(S[i] == S[i+1])&#123; cnt+=1; &#125;else&#123; if(cnt&gt;=3)&#123; buf.push_back(i-cnt+1); buf.push_back(i); result.push_back(buf); &#125; buf.clear(); cnt=1; &#125; &#125; return result; &#125; 找数组左右和相等的中间索引 Find Pivot Index__724123Input: nums = [1, 7, 3, 6, 5, 6]Output: 3 实现 1234567891011121314151617class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size&lt;=2) return -1; int pre=0; long lsum=0,rsum=0; for(auto i:nums) lsum+=i; for(int i=0;i&lt;size;i++)&#123; if( 2*rsum == (lsum - nums[i]) ) return i; rsum += nums[i]; &#125; return -1; &#125;&#125;; 爬台阶的方法 Climbing Stairs _7012345678Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step类似于斐波那契数列 a(n) = a(n-1) + a(n-2)； 实现 1234567891011121314151617int climbStairs(int n) &#123; if(n &lt; 1)&#123; return 0; &#125; if(n &lt; 3)&#123; return n; &#125; int first = 2; int second = 1; int current = 0; for(int i = 3; i &lt;= n; ++i)&#123; current = first + second; second = first; first = current; &#125; return current; &#125; 二进制加法 Add Binary_67(leetcode)1234567Given two binary strings, return their sum (also a binary string).Input: a = "1010", b = "1011"Output: "10101"The input strings are both non-empty and contains only characters 1 or 0. 实现 1234567891011121314151617181920212223242526272829303132333435363738string addBinary(string a, string b) &#123; int s1 = a.size() - 1, s2 = b.size() - 1; int maxlen = max(s1,s2); int carry = 0; string s(maxlen + 1, '0'); if (s1 &lt; s2) &#123; while (s1 &lt; s2) &#123; s1++; a.insert(a.begin(), '0'); &#125; &#125; else if (s2 &lt; s1) &#123; while (s2 &lt; s1) &#123; s2++; b.insert(b.begin(), '0'); &#125; &#125; while (maxlen &gt;= 0) &#123; int sum = (a[maxlen] - 48) + (b[maxlen] - 48)+ carry; if (sum == 3 || sum == 1) s[maxlen] = '1'; else s[maxlen] = '0'; if (sum == 2 || sum == 3) carry = 1; else carry = 0; maxlen--; &#125; if(carry==1) s.insert(s.begin(),'1'); return s; 对称二叉树 101. Symmetric Tree 可以使用树的层次遍历 但是有一个问题，不知道每层存在多少元素，可以使用队列的size进行判断， 或者 使用两个队列 分别保存当前层元素和 下一层元素，当当前层队列为空时，即为遍历完一层，然后交换两个队列 ，两个实现分别为 1 2 解法1 12345678910111213141516171819202122232425262728293031323334353637383940vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; if(root == NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); temp.push_back(root-&gt;val); res.push_back(temp); temp.clear(); while(!q.empty())&#123; int size = q.size(); while(size&gt;0)&#123; TreeNode* a = q.front(); q.pop(); if(a-&gt;left!=NULL) &#123; q.push(a-&gt;left); temp.push_back(a-&gt;left-&gt;val); &#125; if(a-&gt;right!=NULL) &#123; q.push(a-&gt;right); temp.push_back(a-&gt;right-&gt;val); &#125; size--; &#125; if(temp.size()&gt;0) res.push_back(temp); temp.clear(); &#125; reverse(res.begin(),res.end()); return res; &#125; 解法2 1234567891011121314151617181920212223242526272829303132333435vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q_cur,q_next; q_cur.push(root); temp.push_back(root-&gt;val); res.push_back(temp); temp.clear(); while(!q_cur.empty())&#123; TreeNode* a = q_cur.front(); q_cur.pop(); if(a-&gt;left!= NULL)&#123; q_next.push(a-&gt;left); temp.push_back(a-&gt;left-&gt;val); &#125; if(a-&gt;right!=NULL)&#123; q_next.push(a-&gt;right); temp.push_back(a-&gt;right-&gt;val); &#125; if(q_cur.empty())&#123; swap(q_cur,q_next); if(temp.size()&gt;0) res.push_back(temp); temp.clear(); &#125; &#125; reverse(res.begin(),res.end()); return res; &#125; 二叉树的层次反转 107 Binary Tree Level Order Traversal II 给定一个二叉树，返回它从叶子到根节点的数值遍历 实现 可以使用树的层次遍历 但是有一个问题，不知道每层存在多少元素，可以使用队列的size进行判断， 或者 使用两个队列 分别保存当前层元素和 下一层元素，当当前层队列为空时，即为遍历完一层，然后交换两个队列 ，两个实现分别为 1 2 解法1 1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; if(root == NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); temp.push_back(root-&gt;val); res.push_back(temp); temp.clear(); while(!q.empty())&#123; int size = q.size(); while(size&gt;0)&#123; TreeNode* a = q.front(); q.pop(); if(a-&gt;left!=NULL) &#123; q.push(a-&gt;left); temp.push_back(a-&gt;left-&gt;val); &#125; if(a-&gt;right!=NULL) &#123; q.push(a-&gt;right); temp.push_back(a-&gt;right-&gt;val); &#125; size--; &#125; if(temp.size()&gt;0) res.push_back(temp); temp.clear(); &#125; reverse(res.begin(),res.end()); return res; &#125; 实现2 1234567891011121314151617181920212223242526272829303132333435vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q_cur,q_next; q_cur.push(root); temp.push_back(root-&gt;val); res.push_back(temp); temp.clear(); while(!q_cur.empty())&#123; TreeNode* a = q_cur.front(); q_cur.pop(); if(a-&gt;left!= NULL)&#123; q_next.push(a-&gt;left); temp.push_back(a-&gt;left-&gt;val); &#125; if(a-&gt;right!=NULL)&#123; q_next.push(a-&gt;right); temp.push_back(a-&gt;right-&gt;val); &#125; if(q_cur.empty())&#123; swap(q_cur,q_next); if(temp.size()&gt;0) res.push_back(temp); temp.clear(); &#125; &#125; reverse(res.begin(),res.end()); return res; &#125; 叶子节点最小深度 111. Minimum Depth of Binary Tree 返回叶子 (无左右孩子的节点) 节点的最小深度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; int dep =1; queue&lt;TreeNode*&gt; q_cur,q_next; q_cur.push(root); while(!q_cur.empty())&#123; TreeNode* a = q_cur.front(); q_cur.pop(); if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL) return dep; if(a-&gt;left!=NULL) q_next.push(a-&gt;left); if(a-&gt;right!=NULL) q_next.push(a-&gt;right); if(q_cur.empty())&#123; swap(q_cur,q_next); dep+=1; &#125; &#125; return dep; &#125;# 或者使用一个队列 每一次层次遍历 都提前计算出当前层的size 既当前层的元素数量// while(!q.empty())&#123;// int size = q.size();// while(size&gt;0)&#123;// TreeNode* a = q.front();// q.pop(); // if(a-&gt;left==NULL &amp;&amp; a-&gt;right==NULL) // return dep;// if(a-&gt;left!=NULL)// q.push(a-&gt;left);// if(a-&gt;right!=NULL)// q.push(a-&gt;right);// size--;// &#125; // dep+=1;// &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分离式编译]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[C++ 分离式编译模式 是c/c++组织源代码和生成可执行文件的方式，不如同时处理所有.c文件的“全程序编译链接”先进，但是对于内存较小的机器很友好！复杂的源程序需要海量的内存才可以完成全连接编译优化！ 源于C语言，分离式编译：一个项目由若干个源文件共同实现，而每个源文件单独编译生成目标文件(obj),最后将所有的目标文件连接起来形成单一的可执行文件的过程！ 各个cpp文件完全分开编译，然后生成各自的obj目标文件，最后通过连接器link生成一个可执行的exe文件 预处理(Preprocessing) (-E) 编译(Compilation) (-S) 汇编(Assembly) (-c) 连接(Linking) (-o) 参数 含义 -E Preprocess only; do not compile, assemble or link. -S Compile only; do not assemble or link. -c Compile and assemble, but do not link. -o Place the output into . -pie Create a position independent executable. -shared Create a shared library. -x -Wl, Pass comma-separated on to the linker.在生成动态链接库的时候可以传递给链接器参数生成导入库 ldd：可以查看可执行文件 依赖的共享库 分离编译模式的的要点 每个函数或外部变量（全局变量）只能被定义一次，但可以被多次“声明” 123456789using namespace std;void func();void func();void func()&#123; cout&lt;&lt;”This ia a demo”&lt;&lt;endl;&#125;int main()&#123; func();&#125; 函数声明也是有作用域的 一个函数被声明却从未定义，只要没有发生函数调用，编译连接是不会出错的。 12345678910111213141516 #include &lt;iostream&gt;using namespace std;class Demo&#123;public: void func1(); void func2();&#125;;void Demo::func1()&#123; cout&lt;&lt;”This is a demo”&lt;&lt;endl;&#125;int main()&#123; Demo obj;obj.func1();&#125; # 从分离角度来看，func2没有定义，但是因为没有调用func2，所以编译连接时不会寻找具体的函数实现(定义)，从分离编译角度来看，func2有可能在别的源文件实现； 关键是：在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找[当遇到未决符号时它会寄希望于连接器]。 ###模板不能分离式编译 对于模板(指导编译器生成代码的指令)，模板函数的代码并不能直接编译成二进制代码，其中需要一个实例化过程；既，并不是把模板编译成一个可以处理任何类型的实体，而是对于每一个模板实例，模板都会产生一个不同的实体； 1234567891011121314151617181920212223//-------------test.h-------------------// template&lt;typename T&gt; class A &#123; public: void f();//这里只是个声明 &#125;;//-------------test.cpp-----------------// #include”test.h” template&lt;typename T&gt; voidA::f() //模板的实现，但注意：不是具现 &#123; //dosomething &#125;//---------------main.cpp---------------// #include”test.h” int main() &#123; A a; a.f(); &#125; 在编译main.cpp时，文件中只有f函数的声明，只能寄希望于链接器可以在链接的时候找到其实现，但是在链接时，链接器可以在test.cpp找到f函数的实现？显然是不能的 由于是分离式编译，在编译test.cpp时，没有使用到f函数，所以没有实例化，没有实例化，也就没有在.o文件中生成函数的具体实现 但遇到模板时就傻眼了，因为模板仅在需要的时候才会具现化出来，所以，当编译器只看到模板的声明时，它不能具现化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。所以一般的操作也就是将模板的实现一起写在头文件.h中。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板类 函数]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%A8%A1%E6%9D%BF%E7%B1%BB-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[泛型编程既以一种独立于任何特定类型的方式编写代码，可以实现算法和数据结构的分离;简单来说就是代码不局限于类型，模板就是泛型编程的基础。 模板函数 在 C++ 中，模板分为函数模板和类模板两种。函数模板是用于生成函数的，类模板则是用于生成类的。 在模板参数列表中，typename 和 class 关键词含义相同，可互换使用、同时使用，因为typename是在模板广泛使用之后才引入的，所以很多旧程序在使用class 1234567891011121314# 语法template &lt;typename param1,class param2&gt;ret-type func-name(parameter list)&#123; 函数体；&#125;template &lt;class T&gt;void Swap(T &amp;x, T &amp;y, int size)&#123; # size 非模板变量，直接写在形参表中 T tmp = x; x = y; y = tmp;&#125; 其中T为 (形参)类型参数，既 （形参类型 + 形参名字） 编译器在生成具体函数时，会用具体的类型(int\doubule)对模板中的类型参数(T)进行替换，其他部分则原封不动地保留。 模板实例化(显式/隐式) 编译器由模板自动生成函数的过程称为实例化,由模板实例化而得到的函数称为模板函数 模板实例化时还可以显示指定需要实例化的类型模板函数名&lt;类型1,类型2, ...&gt; 如 Swap&lt;int&gt;(2) 一个程序里面同时出现函数模板和普通函数，并且函数名相同 是正确的,并且普通函数的优先级比函数模板的优先级高， 函数模板是编译时自动生 成各种类型的函数实例，如同内联函数，编译时其实现必须可见，一般其实现应该包含在头文件中。 模板函数的声明定义要放在头文件中，不可以分开放在.h和.cpp中。 同样，在一个类中将一个成员函数定义为函数模板时也是要遵从这个规则：实现要放在头文件里。 类模板123456789template &lt;class type&gt; class class-name &#123; // 主体&#125;template &lt;class type&gt;void class-name&lt;type&gt;::func (type a) &#123; // 函数主体&#125; 实例 1234567891011121314151617181920template &lt;class T&gt;class Stack &#123; private: vector&lt;T&gt; elems; // 元素 public: void push(T const&amp;); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const&#123; // 如果为空则返回真。 return elems.empty(); &#125; &#125;;template &lt;class T&gt;void Stack&lt;T&gt;::push (T const&amp; elem) &#123; // 追加传入元素的副本 elems.push_back(elem); &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github page + hexo + next + .top]]></title>
    <url>%2F2019%2F03%2F11%2Fgithub-page-hexo-next-top%2F</url>
    <content type="text"><![CDATA[github page 创建一个仓库，命名方式为 账号 + .github.io ，例如我的仓库名为：junqiangwu.github.io Hexo - MAC os 安装git 安装node.js 安装hexo node.js直接从官网下载dmg客户端安装node.js官网下载 安装完成以后，使用node -v 和 npm -v 查看版本号，确定安装正确 如果找不到命令node: command not found，则需要在系统环境变量中添加 包的路径MAC的环境变量类似于Linux(左边的先加载):/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 打开profile文件，在其中添加1234#默认安装路径在 /usr/local/bin/nodeexport NODE_HOME=&quot;/usr/local&quot; export PATH=$PATH:$NODE_HOME/bin hexo直接命令行安装即可： sudo npm install -g hexo-cli 使用hexo创建本地仓库：12345678# 创建一个blog文件夹mkdir blog# 进入目录cd blog# 初始化目录hexo init# 开启本地服务 # hexo s 即可在localhost:4000 打开hello页面 绑定github page 打开Blog目录，打开站点配置文件 _config.yml ,在deploy添加自己的git仓库地址： 1234# 产生静态网页,每次添加文章之后，都需要这个命令生成静态网页hexo g# 部署到GitHub page上，类似于git pushhexo d 这样就可以通过 name+github.io 地址访问到你的github page Theme Hexo官网：https://hexo.io/themes/里面有特别多的主题可以选择，我在这里选的是next这个主题,效果图 首先clone 下来hexo主题，放到Blog/theme文件里 修改站点配置文件 _config.yml 将里面76行的theme由landscape修改为next 更换新的主题，可能会有一些延迟， 然后就可以通过theme-next的配置文件_config.yml对主题样式进行修改、配置 1234# 新建 分类 和 标签 页面cd ~/bloghexo new page categorieshexo new page tags 具体的主题修改优化配置，可见这个博客，写的很详细：https://zealot.top/设计了头像、背景、评论、缩放等一系列操作 绑定top域名 在仓库里添加CNAME文件 申请一个域名，域名解析 github配置 在仓库里添加一个文件，命名为 CNAME，文件名大写且没有后缀；文件里填写要绑定的域名且不要包含Http://和www 如junqw.top 进入github博客仓库设置(setting)，找到 Custom domain添加域名(junqw.top)后保存即可 域名配置 阿里云购买的域名，这里以阿里云的操作为例，登陆阿里云，依次进入 控制台-万网-域名 找到已购买的域名点击解析按钮，添加两项解析，没试过写ip地址那个，但是这两个解析实测可用 第一项是为了绑定www,注意添加的时候不要忘了最后面的那个&quot;点&quot; 即 junqiangwu.github.io. 这就好了，需要等待一段时间，就可以通过top域名访问你的博客了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>MAC环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Installing PycURL on macOS High Sierra]]></title>
    <url>%2F2019%2F03%2F10%2FInstalling%20PycURL%20on%20macOS%20High%20Sierra%2F</url>
    <content type="text"><![CDATA[Installing PycURL on macOS High Sierra 需要向服务器推送较大的文件，发现python端有一个pycurl库很好的集成了curl命令，在速度上比urllib快很多，不过在Mac端安装的时候总是提示不兼容： 最后在这里找到了解决办法：https://cscheng.info/2018/01/26/installing-pycurl-on-macos-high-sierra.html import pycurlTraceback (most recent call last): File ““, line 1, in ImportError: pycurl: libcurl link-time ssl backend (openssl) is different from compile-time ssl backend (none/other) 如果你没有安装openssl，请安装：brew install openssl或者：brew uggrade openssl 设置环境变量：If you need to have this software first in your PATH run:echo &#39;export PATH=&quot;/usr/local/opt/openssl/bin:$PATH&quot;&#39; &gt;&gt; ~/.bash_profile 卸载之前安装的pycurlpip3 uninstall pycurl 重新安装：1sudo pip3 install --install-option=&quot;--with-openssl&quot; --install-option=&quot;--openssl-dir=/usr/local/opt/openssl&quot; pycurl]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>MAC环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF_Object_Detection API 训练自己模型]]></title>
    <url>%2F2019%2F03%2F10%2FTF-Object-Detection-API-%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[安装Tensorflow_Object_detection_API 依赖库 1Protobuf 、Python-tk、Pillow 1.0、lxml、tf Slim、Jupyter notebook、Matplotlib、Tensorflow、Cython、cocoapi 具体请参考： https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md 安装依赖库：(具体可参考官方文档) 下载源码： 12345678910111213git clone https://github.com/tensorflow/modelssudo apt-get install protobuf-compiler python-pil python-lxml python-tksudo pip3 install Cythonsudo pip3 install jupytersudo pip3 install matplotlib#或者使用pip安装：sudo pip install Cythonsudo pip install pillowsudo pip install lxmlsudo pip install jupytersudo pip install matplotlib 如果使用COCO作为评价指标的话，需要接入coco的pythonApi， 1234git clone https://github.com/cocodataset/cocoapi.gitcd cocoapi/PythonAPImakecp -r pycocotools &lt;path_to_tensorflow&gt;/models/research/ 编译项目From tensorflow/models/research/ 首先protoc编译项目，然后添加环境变量 Mac端： ~./bash_profile 1234567protoc object_detection/protos/*.proto --python_out=.export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim# 如果protoc版本过低，请对应环境下载 https://link.zhihu.com/?target=https%3A//github.com/google/protobuf/releasessudo cp bin/protoc /usr/bin/protoc 再次尝试编译、添加环境 测试安装Ok： python3 object_detection/builders/model_builder_test.py 如果返回Ok 则安装成功，运行setuppython3 setup.py install 制作自己的数据集 并使用API传输训练利用labelImag标注数据，生成xml信息，利用Xml-to-csv.py转换成voc的格式，xml-to-csv脚本： 注意按照自己的文件结构对应修改，我的结构： 123456789101112-train_data/ --...-images/ --test/ ---testingimages.jpg ---image.xml --train/ ---testingimages.jpg ---image.xml --..yourimages.jpg-xml_to_csv.py 1234567891011121314151617181920212223242526272829303132333435import osimport globimport pandas as pdimport xml.etree.ElementTree as ETdef xml_to_csv(path): xml_list = [] for xml_file in glob.glob(path + &apos;/*.xml&apos;): tree = ET.parse(xml_file) root = tree.getroot() for member in root.findall(&apos;object&apos;): value = (root.find(&apos;filename&apos;).text, int(root.find(&apos;size&apos;)[0].text), int(root.find(&apos;size&apos;)[1].text), member[0].text, int(member[4][0].text), int(member[4][1].text), int(member[4][2].text), int(member[4][3].text) ) xml_list.append(value) column_name = [&apos;filename&apos;, &apos;width&apos;, &apos;height&apos;, &apos;class&apos;, &apos;xmin&apos;, &apos;ymin&apos;, &apos;xmax&apos;, &apos;ymax&apos;] xml_df = pd.DataFrame(xml_list, columns=column_name) return xml_dfdef main(): for directory in [&apos;train&apos;,&apos;test&apos;]: image_path = os.path.join(os.getcwd(), &apos;images/&#123;&#125;&apos;.format(directory)) xml_df = xml_to_csv(image_path) xml_df.to_csv(&apos;train_data/&#123;&#125;_labels.csv&apos;.format(directory), index=None) print(&apos;Successfully converted xml to csv.&apos;)main() 将Csv格式的图片信息转换为tf_record格式，提供API训练 首先将上述的images、data移到model/research/object_detedtion文件夹下：利用generate_tfrecord.py转换格式 需要修改 返回的类别和名称 以及文件路径名 https://github.com/junqiangwu/My_Tensorflow/blob/master/object-detection/generate_tfrecord.py From model/research/object_detection/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from __future__ import division from __future__ import print_function from __future__ import absolute_import import os import io import pandas as pd import tensorflow as tf from PIL import Image from object_detection.utils import dataset_util from collections import namedtuple, OrderedDict flags = tf.app.flags flags.DEFINE_string(&apos;csv_input&apos;, &apos;&apos;, &apos;Path to the CSV input&apos;) flags.DEFINE_string(&apos;output_path&apos;, &apos;&apos;, &apos;Path to output TFRecord&apos;) FLAGS = flags.FLAGS # TO-DO replace this with label map def class_text_to_int(row_label): if row_label == &apos;macncheese&apos;: return 1 else: None def split(df, group): data = namedtuple(&apos;data&apos;, [&apos;filename&apos;, &apos;object&apos;]) gb = df.groupby(group) return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)] def create_tf_example(group, path): with tf.gfile.GFile(os.path.join(path, &apos;&#123;&#125;&apos;.format(group.filename)), &apos;rb&apos;) as fid: encoded_jpg = fid.read() encoded_jpg_io = io.BytesIO(encoded_jpg) image = Image.open(encoded_jpg_io) width, height = image.size filename = group.filename.encode(&apos;utf8&apos;) image_format = b&apos;jpg&apos; xmins = [] xmaxs = [] ymins = [] ymaxs = [] classes_text = [] classes = [] for index, row in group.object.iterrows(): xmins.append(row[&apos;xmin&apos;] / width) xmaxs.append(row[&apos;xmax&apos;] / width) ymins.append(row[&apos;ymin&apos;] / height) ymaxs.append(row[&apos;ymax&apos;] / height) classes_text.append(row[&apos;class&apos;].encode(&apos;utf8&apos;)) classes.append(class_text_to_int(row[&apos;class&apos;])) tf_example = tf.train.Example(features=tf.train.Features(feature=&#123; &apos;image/height&apos;: dataset_util.int64_feature(height), &apos;image/width&apos;: dataset_util.int64_feature(width), &apos;image/filename&apos;: dataset_util.bytes_feature(filename), &apos;image/source_id&apos;: dataset_util.bytes_feature(filename), &apos;image/encoded&apos;: dataset_util.bytes_feature(encoded_jpg), &apos;image/format&apos;: dataset_util.bytes_feature(image_format), &apos;image/object/bbox/xmin&apos;: dataset_util.float_list_feature(xmins), &apos;image/object/bbox/xmax&apos;: dataset_util.float_list_feature(xmaxs), &apos;image/object/bbox/ymin&apos;: dataset_util.float_list_feature(ymins), &apos;image/object/bbox/ymax&apos;: dataset_util.float_list_feature(ymaxs), &apos;image/object/class/text&apos;: dataset_util.bytes_list_feature(classes_text), &apos;image/object/class/label&apos;: dataset_util.int64_list_feature(classes), &#125;)) return tf_example def main(_): writer = tf.python_io.TFRecordWriter(FLAGS.output_path) path = os.path.join(os.getcwd(), &apos;images&apos;) examples = pd.read_csv(FLAGS.csv_input) grouped = split(examples, &apos;filename&apos;) num=0 for group in grouped: num+=1 tf_example = create_tf_example(group, path) writer.write(tf_example.SerializeToString()) if(num%100==0): #每完成100个转换，打印一次 print(num) writer.close() output_path = os.path.join(os.getcwd(), FLAGS.output_path) print(&apos;Successfully created the TFRecords: &#123;&#125;&apos;.format(output_path)) if __name__ == &apos;__main__&apos;: tf.app.run() 1234python3 generate_tfrecord.py --csv_input=train_data/train_labels.csv --output_path=train.record python3 generate_tfrecord.py --csv_input=train_data/test_labels.csv --output_path=test.record 会在object_detection目录下生成两个.record文件，将它移到train_data目录下，train_data目录下包含：两个csv 和 两个 .record 在object_detection目录下:123456789101112-images/ --test/ ---testingimages.jpg --train/ ---testingimages.jpg --..yourimages.jpg -train_data --train_labels.csv --test_labels.csv --train.record --test.record 下载预训练模型，配置网络结构信息：12345678wget http://download.tensorflow.org/models/object_detection/ ssd_mobilenet_v1_coco_11_06_2017.tar.gzmkdir training 在training文件夹下编写训练数据标签：object_detection.pbtxt item &#123; id: 1 name: &apos;macncheese&apos; #物品类别 &#125; 从object_detection/samples/config/ssd_mobilenet_v1_pets.config移到training文件下：并作出修改： num_class: 1 batch_size: 24 fine_tune_checkpoint: &quot;ssd_mobilenet_v1_coco_11_06_2017/model.ckpt&quot; 123456train_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;train_data/train.record&quot; &#125; label_map_path: &quot;training/object-detection.pbtxt&quot; &#125; 最后在object_detection文件夹下：运行命令： 1python3 train.py --logtostderr --train_dir=training/ --pipeline_config_path=training/ssd_mobilenet_v1_pets.config train_dir: 训练输出文件的路径 pipeline_config: 网络配置文件的路径 测试输出模型的准确性 利用.py 转换 .pb From model/research/object_detection 123456python3 export_inference_graph.py --input_type image_tensor --pipeline_config_path training/ssd_mobilenet_v1_pets.config --trained_checkpoint_prefix training/model.ckpt-388 --output_directory mac_n_cheese_inference_graph input_type : 保持一致 pipeline: 网络结构配置图 train_checkpoint: ckpt模型保存路径 既上面训练路径的设置位置 out: 输出文件 ####最后利用jupyter notebook加载pb模型进行测试1234567891011121314#修改object_detection_tutorial.ipynb# What model to download.MODEL_NAME = &apos;mac_n_cheese_inference_graph&apos;#Path to frozen detection graph. This is the actual model that is used for the object detection.PATH_TO_CKPT = MODEL_NAME + &apos;/frozen_inference_graph.pb&apos;# List of the strings that is used to add correct label for each box.PATH_TO_LABELS = os.path.join(&apos;training&apos;, &apos;object-detection.pbtxt&apos;)NUM_CLASSES = 1#删除downloand程序，修改加载测试图片的路径，运行即可 所有的配置文件在： https://github.com/junqiangwu/My_Tensorflow/tree/master/object-detection]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mxnet2Caffe]]></title>
    <url>%2F2019%2F03%2F10%2FMxnet2Caffe%2F</url>
    <content type="text"><![CDATA[Mxnet2Caffe 将mxnet静态图symbol转换为caffe的prototxt文本，支持大部分op，caffe不需要的op则需要自己添加，再转换，否则会构建失败 将json转换为prototxt 利用caffe的python接口构建网络，将mxnet的参数param迁移到caffe网络中 构建caffe不支持的op 对结果进行比对 json_2_protxt json2prototxt.py prototxt_basic.py Read mxnet_json file and converte to prototxt 123456789101112131415161718192021222324252627282930313233// json 格式，只要就是op(操作节点和辅助节点null) name attr(参数列表) inputs(输入列表list) &#123; "op": "Activation", "name": "part_0_stage1_unit1_relu1", "attrs": &#123;"act_type": "relu"&#125;, "inputs": [[14, 0, 0]] &#125;, &#123; "op": "null", "name": "part_0_stage1_unit1_conv1_weight", "attrs": &#123; "kernel": "(3, 3)", "no_bias": "True", "num_filter": "64", "pad": "(1, 1)", "stride": "(1, 1)", "workspace": "256" &#125;, "inputs": [] &#125;, &#123; "op": "Convolution", "name": "part_0_stage1_unit1_conv1", "attrs": &#123; "kernel": "(3, 3)", "no_bias": "True", "num_filter": "64", "pad": "(1, 1)", "stride": "(1, 1)", "workspace": "256" &#125;, "inputs": [[15, 0, 0], [16, 0, 0]] &#125;, 读取json文件，并存储相应信息12345678910111213141516171819202122232425262728293031323334353637with open(args.mx_json) as json_file: jdata = json.load(json_file)with open(args.cf_prototxt, "w") as prototxt_file: for i_node in range(0,len(jdata['nodes'])): #logging.info("i_node[%d],'name' %s" %(i_node,jdata['nodes'][i_node]['name'])) node_i = jdata['nodes'][i_node] # 如果当前节点是辅助节点或输入节点(只转换操作节点) 则跳过 if str(node_i['op']) == 'null' and str(node_i['name']) != 'data': continue ''' logging.info('%d, \top:%s, name:%s -&gt; %s'.%(i_node,node_i['op'].ljust(20), node_i['name'].ljust(30), node_i['name']).ljust(20)) ''' ##node[i]个节点 存在的信息 op name param input info = node_i info['top'] = info['name'] info['bottom'] = [] info['params'] = [] # 遍历当前节点的输入 存储辅助参数 for input_idx_i in node_i['inputs']: # jdata['nodes'][input_idx_i[0]] jdana['nodes'][input_index] input_i = jdata['nodes'][input_idx_i[0]] #存储所有输入节点 if str(input_i['op']) != 'null' or (str(input_i['name']) == 'data'): info['bottom'].append(str(input_i['name'])) if str(input_i['op']) == 'null': info['params'].append(str(input_i['name'])) if not str(input_i['name']).startswith(str(node_i['name'])): logging.info(' use shared weight -&gt; %s'% str(input_i['name'])) info['share'] = True write_node(prototxt_file, info) 写prototxt文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 转换 Convolution 节点操作def Convolution(txt_file, info): if info['attrs']['no_bias'] == 'True': bias_term = 'false' else: bias_term = 'true' txt_file.write('layer &#123;\n') txt_file.write(' bottom: "%s"\n' % info['bottom'][0]) txt_file.write(' top: "%s"\n' % info['top']) txt_file.write(' name: "%s"\n' % info['top']) txt_file.write(' type: "Convolution"\n') txt_file.write(' convolution_param &#123;\n') txt_file.write(' num_output: %s\n' % info['attrs']['num_filter']) txt_file.write(' kernel_size: %s\n' % info['attrs']['kernel'].split('(')[1].split(',')[0]) # TODO if 'pad' not in info['attrs']: logging.info('miss Conv_pad, make pad default: 0 ') txt_file.write(' pad: %s\n' % 0) # TODO else: txt_file.write(' pad: %s\n' % info['attrs']['pad'].split('(')[1].split(',')[0]) # TODO# txt_file.write(' group: %s\n' % info['attrs']['num_group']) txt_file.write(' stride: %s\n' % info['attrs']['stride'].split('(')[1].split(',')[0]) txt_file.write(' bias_term: %s\n' % bias_term) txt_file.write(' &#125;\n') if 'share' in info.keys() and info['share']: txt_file.write(' param &#123;\n') txt_file.write(' name: "%s"\n' % info['params'][0]) txt_file.write(' &#125;\n') txt_file.write('&#125;\n') txt_file.write('\n')# -------根据op操作，完善相应的转换函数-----------# 目前包含Conv Pool DepthConv BN Act ele_add Concat FC Reshape etc. def write_node(txt_file, info): if 'label' in info['name']: return if info['op'] == 'null' and info['name'] == 'data': data(txt_file, info) elif info['op'] == 'Convolution': Convolution(txt_file, info) elif info['op'] == 'ChannelwiseConvolution': ChannelwiseConvolution(txt_file, info) elif info['op'] == 'BatchNorm': BatchNorm(txt_file, info) elif info['op'] == 'Activation': Activation(txt_file, info)# elif info['op'] == 'ElementWiseSum': elif info['op'] == 'elemwise_add': ElementWiseSum(txt_file, info) elif info['op'] == '_Plus': ElementWiseSum(txt_file, info) elif info['op'] == 'Concat': Concat(txt_file, info) elif info['op'] == 'Pooling':# Pooling(txt_file, info) Pooling_global(txt_file, info) elif info['op'] == 'Flatten': Flatten(txt_file, info) elif info['op'] == 'FullyConnected': FullyConnected(txt_file, info) elif info['op'] == 'SoftmaxOutput': SoftmaxOutput(txt_file, info) elif info['op'] == 'Cast': Cast(txt_file, info) elif info['op'] == 'SliceChannel': SliceChannel(txt_file, info) elif info['op'] == 'L2Normalization': L2Normalization(txt_file, info) elif info['op'] == 'Reshape': Reshape(txt_file,info) elif info['op'] == 'broadcast_mul': broadcast_mul(txt_file,info) else: logging.warn("Unknown mxnet op: %s" %info['op']) 利用caffe的python接口，构建网络，并迁移mxnet的网络参数1.mxnet2caffe.py Read mxnet_model params_dict and converte to .caffemodel 转换的时候如果存在caffe不支持的op，需要自己添加自定义层，否则在构建网络时，会error，本工程添加了broadcast_mul层caffe添加自定义层的介绍比较多，就跳过了 根据mxnet的API (load) 加载param文件的所有参数字典12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152try: import caffeexcept ImportError: import os, sys sys.path.append("/home/***/codes/mx2caffe/caffe/python/") import caffe#读取全部param 参数字典 _, arg_params, aux_params = mx.model.load_checkpoint(args.mx_model, args.mx_epoch)all_keys = arg_params.keys() + aux_params.keys()# 利用caffe的python接口，读取刚转换的proto构建网络，net = caffe.Net(args.cf_prototxt, caffe.TRAIN)for i_key,key_i in enumerate(all_keys): try: if 'data' is key_i: pass # 在mxnet字典中，存有caffe不需要的后缀，_weight _bias # 需要确认caffe的参数保存顺序 [0]是weight [1]是bias 其它op 类似查看proto结构设计 elif '_weight' in key_i: key_caffe = key_i.replace('_weight','') net.params[key_caffe][0].data.flat = arg_params[key_i].asnumpy().flat elif '_bias' in key_i: key_caffe = key_i.replace('_bias','') net.params[key_caffe][1].data.flat = arg_params[key_i].asnumpy().flat elif '_gamma' in key_i: key_caffe = key_i.replace('_gamma','_scale') net.params[key_caffe][0].data.flat = arg_params[key_i].asnumpy().flat elif '_beta' in key_i: key_caffe = key_i.replace('_beta','_scale') net.params[key_caffe][1].data.flat = arg_params[key_i].asnumpy().flat elif '_moving_mean' in key_i: key_caffe = key_i.replace('_moving_mean','') net.params[key_caffe][0].data.flat = aux_params[key_i].asnumpy().flat net.params[key_caffe][2].data[...] = 1 elif '_moving_var' in key_i: key_caffe = key_i.replace('_moving_var','') net.params[key_caffe][1].data.flat = aux_params[key_i].asnumpy().flat net.params[key_caffe][2].data[...] = 1 else: sys.exit("Warning! Unknown mxnet:&#123;&#125;".format(key_i)) print("% 3d | %s -&gt; %s, initialized." %(i_key, key_i.ljust(40), key_caffe.ljust(30))) except KeyError: print("\nWarning! key error mxnet:&#123;&#125;".format(key_i)) # ------------------------------------------# Finishnet.save(args.cf_model)print("\n- Finished.\n") 对转换结果进行比对确认 mxnet_test.py Debug mxnet output and you can compare the result with the converted caffemodel 使用mxnet debug， 打印需要对比的参数，并且输出指定层的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import mxnet as mxdef load_checkpoint_single(model, param_path): arg_params = &#123;&#125; aux_params = &#123;&#125; save_dict = mx.nd.load(param_path) for k, value in save_dict.items(): arg_type, name = k.split(':', 1) if arg_type == 'arg': arg_params[name] = value if arg_type == 'aux': aux_params[name] = value else : pass model.set_params(arg_params, aux_params, allow_missing=False) arg_params, aux_params = model.get_params() return arg_params, aux_paramsfull_param_path = 'se_resnet34/base-0000.params'fmodel = mx.sym.load('se_resnet34/base-symbol.json')# 获取mxnet网络的所有layer参数all_layers = fmodel.get_internals()# 修改这里为需要输出layer的name+output即可指定层输出 ‘name_output’fmodel = all_layers['flat_output']fullmodel = mx.mod.Module(symbol=fmodel,data_names=['data'],label_names=[])img = []img = get_image_gray('before_forward.jpg')fullmodel.bind(data_shapes=[('data', (1, 1, 108, 108))], label_shapes=None, for_training=False, force_rebind=False)arg_params, aux_params = load_checkpoint_single(fullmodel, full_param_path)fullmodel.set_params(arg_params,aux_params)file1=open('se_resnet34.txt','w')tic=time.time()fullmodel.forward(Batch([mx.nd.array(img)]))prob = fullmodel.get_outputs()[0].asnumpy()prob = prob.astype(np.float64)prob = prob.reshape(-1,1)# 以特定的格式保存结果np.savetxt(file1,prob,fmt='%.12f')file1.close() 然后利用Caffe 加载刚才转换的网络，打印输出，对比结果精度，如果出现问题，则需要逐层排查，本工程在SENet网络上测试正常 工程项目地址 https://github.com/junqiangwu/Mxnet2Caffe-Tensor-RT-SEnet TODO: add caffe_plugin_layer Tensor RT load caffe_model Tensor RT supported Se_Resnet]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>Mxnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAS (Neural Architecture Search)]]></title>
    <url>%2F2019%2F03%2F09%2FFBNET%2F</url>
    <content type="text"><![CDATA[NAS(Neural Architecture Search)FBNet Hardware-Aware Efficient ConvNet Design via Differentiable Neural Architecture SearchImplementation of FBNet with MXNet paper address: https://arxiv.org/pdf/1812.03443.pdf Implemented Net: FBNet FBNet Based on Se_Resnet_50_Architecture other block_type architecture cound be easily implement by modify fbnet-symbol/block.py Code: blocks.py: Define blocks symbols FBNet.py: Define FBNet Class. FBNet_SE.py: Define FBNet Architecture based on Se_resnet_50. blocks_se.py: Define blocks symbols based on new search space,include [Resnet_50,Se,Group_Conv,Channel_shuffle,Deform_Conv] util.py: Define some functions. test.py: Run test. block_speed_test.py: test block lat in real environment(1080Ti) Differences from original paper: The last conv layer’s num_filters is repalced by feature_dim specified by paramters Use Amsoftmax, Arcface instead of FC, but you can set model_type to softamx to use fc Default input shape is 3,108,108, so the first conv layer has stride 1 instead of 2. Add BN out of blocks, and no bn inside blocks. Last conv has kernel size 3,3 Use + in loss not *. Adding gradient rising stage in cosine decaying schedule. Code in fbnet-symbom/util/CosineDecayScheduler_Grad How to train:If you want to modify the network structure or the learning rate adjustment function, you need to modify the source code,otherwise you can use this command directly: 1python test.py --gpu 0,1,2,3,4,5,6 --log-frequence 50 --model-type softmax --batch-size 32 How to retrain:When we want to train the large dataset and hope to change learning rate manually, or the machine is suddenly shutdown due to some reason,of course, we definitely hope we can continue to train model with previous trained weights. Then, your can use this cmd: 1python test.py --gpu 0,1,2,3,4,5,6 --log-frequence 50 --model-type softmax --batch-size 32 --load-model-path ./model This can load the latest model params for retrain,If you want to load the model with specific epoch,you can use –load-model-path ./model/*.params ,This means you can retrain your model from specific model. TODO: sample script, for now just save $\theta$ cosine decaying schedule lat in real environment DataParallel implementation]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
</search>
