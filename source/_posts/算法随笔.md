---
title: 算法随笔
date: 2019-03-11 22:50:47
comments: true
tags:
- Algorithm

categories:
- Algorithm
---

##算法随笔

### 1.原地删除重复的数字
> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```
**实现**
```
int remove_duplicates(int a[],int size){

    int index = 0;
    for (int i=0;i<size;i++){
    // 一直寻找到不重复的元素，进行交换，index+1
        if(a[index] != a[i]){
            index++;
            a[index] = a[i];
        }
    }
    index++;
    return index;
}
```


### 2.数组中出现次数超过一半的元素
> 数组(无序)中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

#### 解法1
> 如果数据量小，可以对数组进行排序，那么数组中间n/2的数就是出现次数超过一半的数,复杂度O(nlogn)

#### 解法2
> 每次删除数组中两个不同的元素，删除后，要查找的那个元素的个数仍然超过删除后的元素总数的一半

- 需要两个辅助参数，一个是出现的数值，一个是该数值出现的次数

```

template <typename T>
void FindOneNumber(T a[],int size){
    if( size <= 0) return -1;
    int nTimes = 1;
    int pre = a[0];

    for(int i=1;i<size;i++){
        if (pre == a[i]){
            nTimes++;
        }else{
            if(nTimes==0){
                pre = a[i];
                nTimes=1;
            }else{
                nTimes--;
            }
        }
    }
    return pre;
}
```


### 3.将数值向右移动K个位置(非负数)

#### 解法1
> 每次遍历数组，可以向后移动一位，移动k个位置，则需要k次遍历，O(k*n)
```
void move_k(int a[],int size,int k){
    // 求需要移动的最小步数，
    int loca = size%k;
    for(int i=0;i<loca;i++){
        int tmp = a[size-1];
        for(int j=size-1;j>=1;j--){
            a[j] = a[j-1];
        }
        a[0] = tmp;
    }
}
# 时间复杂度 O(k*n)  size/k  
```

#### 解法2
> 借助O(n)的空间，将数组复制到新数组中，然后遍历重新赋值即可，时间O(n)
> string 形参，可以使用引用`const string& str`，减少内存的拷贝

```
void move_k(int a[],int size,int k){
    int loca = size%k;
    int tmp[size];
    # C风格的数组复制方法(memset etc.)
    memcpy(tmp,a,size*sizeof(int));

    for(int i=0;i<size;i++){
        a[(i+loca)%size] = tmp[i];
    }
}
```

### 4.判断重复数字
> 长度为n的数组，赋值为1~n，判断是否存在重复元素

> 这个数组的特性是，1~n每个值都使用一次才会不重复，所以我们可以将数组对应位置设置为对应的值，去判断是否为冲突

```
//遍历数组，假设第i个位置的数字为j，则通过交换将j换到下标为j的位置上，直到所有数字都出现在自己对应的下表处，或发生了冲突。
//时间复杂度：O(n)，空间复杂度：O(1)

bool find_dup(int a[],int size){
    if(size<=1) return false;
    
    for(int i=0;i<size;i++){
        int index = a[i];
        if(index-1== i) continue;
        // 交换前index位置处已经存在index值，这个数字重复
        if(a[index-1]==index){
            return false;
        }
        a[i] = a[index-1];
        a[index-1] = index;
    }
}

```

#### 变形2
- 普通的数组，则可以通过排序，然后判断前后元素是否相同来确定是否有重复元素
- 或者利用STL库的set容器，它保存有序的无重复的数组，支持插入，删除，查找等操作，所有的操作的都是严格在logn时间之内完成，效率非常高

```
return nums.size() > set<int>(nums.begin(),nums.end()).size();

```


### 5.找出只出现一次的元素
> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。(线性复杂度)

#### 解法1
> 因为其它元素都出现两次，只有一个出现一次，就可以将数组先排序，然后以步长2遍历一次数组，找到 a[i] != a[i+1] 的即可

#### 解法2

> 可以使用异或运算进行判定，由于都是出现偶数次，而`0⊕0=0,1⊕0=1,0⊕1=1,1⊕1=0`,且异或满足交换律，所以可以对整个数组进行异或运算，最后得到的结果即为单次出现的数字

```
int arr[5] = {4,2,1,2,4}
4⊕2⊕1⊕2⊕4 = 4⊕4⊕2⊕2⊕1 = (0)⊕(0)⊕1 = 1
```
**实现**

```
    int find_dup2(int a[],int size){
        int temp = 0;
        for(int i=0;i<size;i++){
            temp = temp^a[i];
        }
        return temp;
    }
```


### 6.求数组的交集
- 给定两个数组，编写一个函数来计算它们的交集。

```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
- 我们可以不考虑输出结果的顺序。

**进阶:**
- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

#### 解法1

```
# 最暴力的方法，时间O(n^2)  
void find_jiao(int a[],int b[],int size_a,int size_b){
    vector<int> c;
    
    for(int i=0;i<size_a;i++){
        int tmp = a[i];
        for(int j=0;j<size_b;j++){
            if(tmp == b[j]){
               c.push_back(tmp);
               b[j] = -1;
               break;   //找到一样的则跳出，比对第一层遍历数组中的下一个数值
    }}}
}
```

#### 排序数组，找交集
> 如果两个数组是有序的，则可以分别设置一个索引，如果a[index1]<b[index2],则a索引+1，反之亦然，如果两者相等，则存储当前值，并且两个索引都+1

```
vector<int> find_jiao(int a[],int b[],int size_a,int size_b){
    int index1 = 0,index2 = 0;
    vector<int> c;

    shell_sort(a,size_a);
    shell_sort(b,size_b);

    while(index1<size_a && index2<size_b){
        if(a[index1] < b[index2]){
            index1++;
        }
        else if(a[index1] > b[index2]){
            index2++;
        }
        else{
            c.push_back(a[index1]);
            index1++;
            index2++;
        }
    }
    return c;
}

```

### 7. Plus One 加1
> 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字,你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```
**实现**
```
void plus_one(int a[],int size){

    for(int i=size-1;i>=0;i--){
        if(a[i]<9 ){
            a[i]+=1;
            break;
        }else{
            a[i]=0;
            i++;
        }
    }
}
```


### 8. 移动所有的0到末尾 
> 使用一个索引标志，遍历一次数组，遍历的同时将非0的元素交换到标志索引处，最后将剩余位置填充0即可！

```
void move_zero(int a[],int size){
    int i=0;

    for(int x=0;x<size;x++){
        if(a[x]!=0) {
            a[i] = a[x];
            i++;
        }
    }
    for(;i<size;i++){
        a[i]=0;  }
}

```

### 9.反转字符串
> 输入: "A man, a plan, a canal: Panama"
> 输出: "amanaP :lanac a ,nalp a ,nam A"

```
void reverseString(string& str){
    int i=0,j=str.size()-1;
    while(i<j){
//      swap(str[i++],str[j--]);
        char s = str[i];
        str[i] = str[j];
        str[j] = s;
        i++;j--;
    }
    printf("\n str: %s \n",str.c_str());

}

```



### 10.字母异位词

> 利用了字母易位词即为各个字母的数目相同，而顺序不一致。我们从另外一个角度思考，字母一共有多少个？很明显，只有26个（只考虑小写字母）。那么，我们可以为字符串s1和s2分别设置26个计数器，然后判断这对应位置的计数是否相等，如果对应计数完全相等，则为字母易位词

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**实现**

```
bool isAnagram(string s, string t) {
    if( s.size() != t.size()) return false;
    
    int cnt1[26],cnt2[26];
    memset(cnt1,0,26* sizeof(int));
    memset(cnt2,0,26* sizeof(int));
    
    for(int i=0;i<s.size();i++){
        cnt1[s[i]-'a']++;
        cnt2[s[i]-'a']++;
    }

    for(int i=0;i<26;i++){
        if(cnt1[i] != cnt2[i])
            return false;
    }
    return true;
}
```


### 11.回文字符串
/********11. 回文字符串  **************/

bool isPalindrome(const string& s) {

    int star =0,end = s.size()-1;

    while(star>end){
        if(toupper(s[star] == s[end]))
        {
            star++; end--;
        }else{
            return false;
        }
    }
    return true,
}


### 12.查找字符串数组最长前缀

```
例：
输入: [“flower”,”flow”,”flight”] 输出: “fl” 示例 2:
输入: [“dog”,”racecar”,”car”] 输出: “” 解释: 输入不存在公共前缀。 说明:
# 所有输入只包含小写字母 a-z 
```

```
string longestCommonPrefix(vector<string>& strs) {
        string res;
        if(strs.empty()){
            return "";
        }
        for(int i=0;i<strs[0].size();i++){
            char c=strs[0][i];
            for(int j=1;j<strs.size();j++){
                if(i>strs[j].size()-1||c!=strs[j][i]){
                    return res;
                }
            }
            res.push_back(c);
        }
        return res;

    }

```

### 13.合并两个有序链表
```
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**实现**
```
ListNode* Merge_two(ListNode *l,ListNode* r){
    if(l->next==NULL && r->next==NULL) return NULL;

    ListNode dumpy(0);
    ListNode* tmp=&dumpy;

    while(l->next!=NULL && r->next!=NULL){
        if(l->val > r->val){
            tmp->next = r;
            r = r->next;
        }else{
            tmp->next = l;
            l = l->next;
        }
        tmp = tmp->next;
    }

    if(l!=NULL){
        tmp->next=l;
    }
    if(r!=NULL){
        tmp->next=r;
    }

    return tmp.next;
}

```