---
title: 分离式编译
date: 2019-03-11 17:05:56
comments: true

tags:
- C++
categories:
- C++

---
# C++ 分离式编译模式
> 是c/c++组织源代码和生成可执行文件的方式，不如同时处理所有.c文件的“全程序编译链接”先进，但是对于内存较小的机器很友好！复杂的源程序需要海量的内存才可以完成全连接编译优化！

- 源于C语言，分离式编译：**一个项目由若干个源文件共同实现，而每个源文件单独编译生成目标文件(obj),最后将所有的目标文件连接起来形成单一的可执行文件的过程！**

> 各个cpp文件完全分开编译，然后生成各自的obj目标文件，最后通过连接器link生成一个可执行的exe文件

1. 预处理(Preprocessing) (-E)
2. 编译(Compilation)  (-S)
3. 汇编(Assembly)  (-c)
4. 连接(Linking)  (-o)


| 参数 | 含义 |
| :-: | :-: |
| -E | Preprocess only; do not compile, assemble or link. |
| -S | Compile only; do not assemble or link. |
| -c | Compile and assemble, but do not link. |
| -o <file> | Place the output into <file>. |
| -pie | Create a position independent executable. |
| -shared | Create a shared library. |
| -x <language> |  |
| -Wl,<options> |  Pass comma-separated <options> on to the linker.在生成动态链接库的时候可以传递给链接器参数生成导入库

> ldd：可以查看可执行文件 依赖的共享库

## 分离编译模式的的要点
1. 每个函数或外部变量（全局变量）只能被定义一次，但可以被多次“声明”
```
using namespace std;
void func();
void func();
void func(){
         cout<<”This ia a demo”<<endl;
}
int main(){
         func();
}
```

1. 函数声明也是有作用域的
2. 一个函数被声明却从未定义，只要没有发生函数调用，编译连接是不会出错的。

```
 #include <iostream>
using namespace std;
class Demo{
public:
         void func1();
         void func2();
};
void Demo::func1(){
         cout<<”This is a demo”<<endl;
}
int main(){
         Demo obj;
obj.func1();
}

 # 从分离角度来看，func2没有定义，但是因为没有调用func2，所以编译连接时不会寻找具体的函数实现(定义)，从分离编译角度来看，func2有可能在别的源文件实现；
```

***_关键是：在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找[当遇到未决符号时它会寄希望于连接器]。_***



###模板不能分离式编译

对于模板(指导编译器生成代码的指令)，模板函数的代码并不能直接编译成二进制代码，其中需要一个实例化过程；既，并不是把模板编译成一个可以处理任何类型的实体，而是对于每一个模板实例，模板都会产生一个不同的实体；


```
//-------------test.h-------------------//
    template<typename T>
    class A
    {
    　　public:
    　　　　void f();//这里只是个声明
    };

//-------------test.cpp-----------------//
    #include”test.h”
    template<typename T>
　　 voidA::f()  //模板的实现，但注意：不是具现
　　 {
　　   //dosomething }

//---------------main.cpp---------------//

    #include”test.h”
　　int main()
　　{
　　　　A a;
　　   a.f();
    }

```
**在编译main.cpp时，文件中只有f函数的声明，只能寄希望于链接器可以在链接的时候找到其实现，但是在链接时，链接器可以在test.cpp找到f函数的实现？显然是不能的**

**由于是分离式编译，在编译test.cpp时，没有使用到f函数，所以没有实例化，没有实例化，也就没有在.o文件中生成函数的具体实现**

> 但遇到模板时就傻眼了，因为模板仅在需要的时候才会具现化出来，所以，当编译器只看到模板的声明时，它不能具现化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。
所以一般的操作也就是将模板的实现一起写在头文件.h中。
