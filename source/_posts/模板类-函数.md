---
title: 模板类 函数
date: 2019-03-11 14:55:06
comments: true
tags:
- C++

categories:
- C++

---

## 泛型编程
既以一种独立于任何特定类型的方式编写代码，可以实现算法和数据结构的分离;简单来说就是代码不局限于类型，模板就是泛型编程的基础。

## 模板函数
> 在 C++ 中，模板分为函数模板和类模板两种。函数模板是用于生成函数的，类模板则是用于生成类的。

> 在模板参数列表中，typename 和 class 关键词含义相同，可互换使用、同时使用，因为typename是在模板广泛使用之后才引入的，所以很多旧程序在使用class


```
# 语法
template <typename param1,class param2>
ret-type func-name(parameter list)
{
    函数体；
}

template <class T>
void Swap(T &x, T &y, int size)
{   # size 非模板变量，直接写在形参表中
    T tmp = x;
    x = y;
    y = tmp;
}
```
**其中T为 (形参)类型参数，既 （形参类型 + 形参名字）**
- 编译器在生成具体函数时，会用具体的类型(int\doubule)对模板中的类型参数(T)进行替换，其他部分则原封不动地保留。

**模板实例化(显式/隐式)** 
- 编译器由模板自动生成函数的过程称为实例化,由模板实例化而得到的函数称为模板函数

> 模板实例化时还可以显示指定需要实例化的类型
`模板函数名<类型1,类型2, ...>` 如 `Swap<int>(2)`

>> 一个程序里面同时出现函数模板和普通函数，并且函数名相同 是正确的,并且普通函数的优先级比函数模板的优先级高，


- 函数模板是编译时自动生 成各种类型的函数实例，如同内联函数，编译时其实现必须可见，一般其实现应该包含在头文件中。
- 模板函数的声明定义要放在头文件中，不可以分开放在.h和.cpp中。 
- 同样，在一个类中将一个成员函数定义为函数模板时也是要遵从这个规则：实现要放在头文件里。


## 类模板

```
template <class type> class class-name {
    // 主体
}

template <class type>
void class-name<type>::func (type a) 
{ 
   //  函数主体
} 
```

**实例**

```py
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
};

template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 

```